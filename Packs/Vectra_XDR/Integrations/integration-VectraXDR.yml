category: Network Security
commonfields:
  id: VectraXDR
  version: -1
configuration:
- additionalinfo: URL of the Vectra AI platform.
  display: Server URL
  name: server_url
  required: true
  type: 0
- additionalinfo: Identifies a client or application for authentication and authorization in the Vectra AI platform.
  display: Client ID
  name: client_id
  required: true
  type: 0
- additionalinfo: Secret key used for secure communication with the Vectra AI platform.
  display: Client Secret Key
  hidden: false
  name: client_secret_key
  required: true
  type: 4
- additionalinfo: When checked, no SSL certificates check will be done when interracting with the Vectra XDR API. It's insecure. (Default - unchecked)
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: Use the system proxy settings to reach with the Vectra XDR API.
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- additionalinfo: The maximum number of entities to fetch each time. If the value is greater than 200, it will be considered as 200. The maximum is 200.
  defaultvalue: '50'
  display: Max Fetch
  hidden: false
  name: max_fetch
  required: false
  type: 0
- additionalinfo: "The date or relative timestamp from which to begin fetching entities.\n\nSupported formats: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ.\n    \nFor example: 01 May 2023, 01 Mar 2021 04:45:33, 2022-04-17T14:05:44Z."
  defaultvalue: 1 hour
  display: First Fetch Time
  hidden: false
  name: first_fetch
  required: false
  type: 0
- additionalinfo: The mirroring direction in which to mirror the entities. You can mirror "Incoming" (from Vectra to XSOAR), "Outgoing" (from XSOAR to Vectra), or in both directions.
  display: Mirroring Direction
  hidden: false
  name: mirror_direction
  options:
  - Incoming
  - Outgoing
  - Incoming And Outgoing
  required: false
  type: 15
- additionalinfo: The tag value should be used to mirror the entity note by adding the same tag in the notes.
  defaultvalue: note
  display: Mirror tag for notes
  hidden: false
  name: note_tag
  required: false
  type: 0
- additionalinfo: Entity Type(Host, Account).
  display: Entity Type
  hidden: false
  name: entity_type
  options:
  - Account
  - Host
  required: false
  type: 16
- additionalinfo: Retrieve only prioritize entities based on the configuration on the Vectra platform. If not selected will fetch all entities.
  defaultvalue: Yes
  display: Prioritized
  hidden: false
  name: is_prioritized
  options:
  - Yes
  - No
  required: false
  type: 15
- additionalinfo: Retrieve entities that contain any of the tags specified. Supports comma-separated values.
  display: Tags
  hidden: false
  name: tags
  required: false
  type: 0
- additionalinfo: Retrieve detections belonging to a specified category.
  display: Detection Category
  hidden: false
  name: detection_category
  options:
  - Command & Control
  - Botnet
  - Reconnaissance
  - Lateral Movement
  - Exfiltration
  - Info
  required: false
  type: 15
- additionalinfo: Retrieve detections belonging to a specified detection type.
  display: Detection Type
  hidden: false
  name: detection_type
  required: false
  type: 0
- additionalinfo: If the entity's urgency score is equal to or less than the configured threshold, it would be considered as a "Low" Severity Incident. Default is 30.
  defaultvalue: '30'
  display: Specify the numeric value of "Urgency Score" for mapping the Low Incident Severity.
  hidden: false
  name: urgency_score_low_threshold
  required: false
  type: 0
- additionalinfo: If the entity's urgency score is equal to or less than the configured threshold, it would be considered as a "Medium" Severity Incident.Default is 50.
  defaultvalue: '50'
  display: Specify the numeric value of "Urgency Score" for mapping the Medium Incident Severity.
  hidden: false
  name: urgency_score_medium_threshold
  required: false
  type: 0
- additionalinfo: "If the entity's urgency score is equal to or less than the configured threshold, \nit would be considered as a \"High\" Severity Incident and if urgency score greater than threshold, it would be considered as a \"Critical\" Severity Incident. Default is 80."
  defaultvalue: '80'
  display: Specify the numeric value of "Urgency Score" for mapping the High Incident Severity.
  hidden: false
  name: urgency_score_high_threshold
  required: false
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
description: This integration allows to create incidents based on Vectra XDR Entities.
display: Vectra XDR (Partner Contribution)
name: VectraXDR
script:
  commands:
  - arguments:
    - default: false
      description: Filter by username.
      isArray: false
      name: username
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Filter users with the specified role.
      isArray: false
      name: role
      predefined:
      - Admin
      - Read-Only
      - Restricted Admin
      - Security Analyst
      - Setting Admin
      - Super Admin
      required: false
      secret: false
    - default: false
      description: |-
        Return only the users which have a last login timestamp equal to or after the given timestamp.

        Supported formats: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ.

        For example: 01 May 2023, 01 Mar 2021 04:45:33, 2022-04-17T14:05:44Z.
      isArray: false
      name: last_login_timestamp
      required: false
      secret: false
    deprecated: false
    description: Returns a list of users.
    execution: false
    name: vectra-user-list
    outputs:
    - contextPath: Vectra.User.id
      description: The ID of the User.
      type: Number
    - contextPath: Vectra.User.user_id
      description: The ID of the User.
      type: Number
    - contextPath: Vectra.User.username
      description: Username of the user.
      type: String
    - contextPath: Vectra.User.email
      description: The email associated with the user.
      type: String
    - contextPath: Vectra.User.role
      description: The role associated with the user.
      type: String
    - contextPath: Vectra.User.last_login_timestamp
      description: Last login timestamp in UTC format of the user.
      type: String
    - contextPath: Vectra.User.last_login
      description: Last login timestamp of the user.
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: Fetch only entities whose priority score is above the configured priority threshold will be included in the response.
      isArray: false
      name: prioritized
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: false
      secret: false
    - default: false
      description: Filter by a tag or a comma-separated list of tags.
      isArray: false
      name: tags
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Filter on entity activation state.
      isArray: false
      name: state
      predefined:
      - active
      - inactive
      required: false
      secret: false
    - default: false
      description: Orders records by last timestamp or urgency score. Default sorting is by urgency score in descending order. Use the minus symbol (-) to sort scores in descending order. Multiple ordering fields can be specified with a comma-separated list (e.g., ordering=urgency_score,-name).
      isArray: false
      name: ordering
      required: false
      secret: false
    - default: false
      description: |-
        Return only the entities which have a last detection timestamp equal to or after the given timestamp.

        Supported formats: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ.

        For example: 01 May 2023, 01 Mar 2021 04:45:33, 2022-04-17T14:05:44Z.
      isArray: false
      name: last_detection_timestamp
      required: false
      secret: false
    - default: false
      defaultValue: '1'
      description: Enables the caller to specify a particular page of results.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: Specify the desired page size for the request. Maximum is 5000.
      isArray: false
      name: page_size
      required: false
      secret: false
    - default: false
      description: |-
        Return only the entities which have a last modified timestamp equal to or after the given timestamp.

        Supported formats: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ.

        For example: 01 May 2023, 01 Mar 2021 04:45:33, 2022-04-17T14:05:44Z.
      isArray: false
      name: last_modified_timestamp
      required: false
      secret: false
    deprecated: false
    description: Returns a list of entities.
    execution: false
    name: vectra-entity-list
    outputs:
    - contextPath: Vectra.Entity.id
      description: ID of the entity.
      type: Number
    - contextPath: Vectra.Entity.name
      description: Name of the entity.
      type: String
    - contextPath: Vectra.Entity.breadth_contrib
      description: Breadth contribution of the entity.
      type: Number
    - contextPath: Vectra.Entity.importance
      description: Entity importance.
      type: Number
    - contextPath: Vectra.Entity.type
      description: Type of the entity.
      type: String
    - contextPath: Vectra.Entity.is_prioritized
      description: Entity is prioritized or not.
      type: Boolean
    - contextPath: Vectra.Entity.severity
      description: Severity of the entity.
      type: String
    - contextPath: Vectra.Entity.urgency_score
      description: Urgency score of the entity.
      type: Number
    - contextPath: Vectra.Entity.velocity_contrib
      description: Velocity contribution of the entity.
      type: Number
    - contextPath: Vectra.Entity.detection_set
      description: Set of detections related to entity.
      type: String
    - contextPath: Vectra.Entity.last_detection_timestamp
      description: Time of the last detection activity related to entity.
      type: Date
    - contextPath: Vectra.Entity.notes.id
      description: Notes of the entity.
      type: String
    - contextPath: Vectra.Entity.notes.dateCreated
      description: Created date of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.dateModified
      description: Modified date of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.createdBy
      description: Created user of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.ModifiedBy
      description: Modified user of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.note
      description: Note of the entity.
      type: String
    - contextPath: Vectra.Entity.attack_rating
      description: Attack Ratting of the entity.
      type: Number
    - contextPath: Vectra.Entity.privilege_level
      description: Privilege Level of the entity.
      type: String
    - contextPath: Vectra.Entity.privilege_category
      description: Privilege Category of the entity.
      type: String
    - contextPath: Vectra.Entity.attack_profile
      description: Attack Profile of the entity.
      type: String
    - contextPath: Vectra.Entity.sensors
      description: Sensors of the entity.
      type: Unknown
    - contextPath: Vectra.Entity.state
      description: State of the entity.
      type: String
    - contextPath: Vectra.Entity.tags
      description: Tags of the entity.
      type: Unknown
    - contextPath: Vectra.Entity.url
      description: Url link of the entity.
      type: String
    - contextPath: Vectra.Entity.host_type
      description: Host type of the entity.
      type: Unknown
    - contextPath: Vectra.Entity.account_type
      description: Account type of the entity.
      type: String
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - host
      - account
      required: true
      secret: false
    deprecated: false
    description: Describes an entity by ID.
    execution: false
    name: vectra-entity-describe
    outputs:
    - contextPath: Vectra.Entity.id
      description: ID of the entity.
      type: Number
    - contextPath: Vectra.Entity.name
      description: Name of the entity.
      type: String
    - contextPath: Vectra.Entity.breadth_contrib
      description: Breadth contribution of the entity.
      type: Number
    - contextPath: Vectra.Entity.importance
      description: Entity importance.
      type: Number
    - contextPath: Vectra.Entity.type
      description: Type of the entity.
      type: String
    - contextPath: Vectra.Entity.is_prioritized
      description: Entity is prioritized or not.
      type: Boolean
    - contextPath: Vectra.Entity.severity
      description: Severity of the entity.
      type: String
    - contextPath: Vectra.Entity.urgency_score
      description: Urgency score of the entity.
      type: Number
    - contextPath: Vectra.Entity.velocity_contrib
      description: Velocity contribution of the entity.
      type: Number
    - contextPath: Vectra.Entity.detection_set
      description: Set of detections related to the entity.
      type: String
    - contextPath: Vectra.Entity.last_detection_timestamp
      description: Time of the last detection activity related to the entity.
      type: Date
    - contextPath: Vectra.Entity.last_modified_timestamp
      description: Time of the last modification activity related to the entity.
      type: Date
    - contextPath: Vectra.Entity.notes.id
      description: Notes of the entity.
      type: String
    - contextPath: Vectra.Entity.notes.dateCreated
      description: Created date of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.dateModified
      description: Modified date of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.createdBy
      description: Created user of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.ModifiedBy
      description: Modified user of the Note.
      type: String
    - contextPath: Vectra.Entity.notes.note
      description: Note of the entity.
      type: String
    - contextPath: Vectra.Entity.attack_rating
      description: Attack Ratting of the entity.
      type: Number
    - contextPath: Vectra.Entity.privilege_level
      description: Privilege Level of the entity.
      type: String
    - contextPath: Vectra.Entity.privilege_category
      description: Privilege Category of the entity.
      type: String
    - contextPath: Vectra.Entity.attack_profile
      description: Attack Profile of the entity.
      type: String
    - contextPath: Vectra.Entity.sensors
      description: Sensors of the entity.
      type: Unknown
    - contextPath: Vectra.Entity.state
      description: State of the entity.
      type: String
    - contextPath: Vectra.Entity.tags
      description: Tags of the entity.
      type: Unknown
    - contextPath: Vectra.Entity.url
      description: Url link of the entity.
      type: String
    - contextPath: Vectra.Entity.host_type
      description: Host type of the entity.
      type: Unknown
    - contextPath: Vectra.Entity.account_type
      description: Account type of the entity.
      type: Unknown
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: Enables the caller to specify a particular page of results.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: Specify the desired page size for the request. Maximum is 5000.
      isArray: false
      name: page_size
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The category of the detection.
      isArray: false
      name: detection_category
      predefined:
      - Command & Control
      - Botnet
      - Reconnaissance
      - Lateral Movement
      - Exfiltration
      - Info
      required: false
      secret: false
    - default: false
      description: Filter by detection type.
      isArray: false
      name: detection_type
      required: false
      secret: false
    - default: false
      description: "Return only the detections which have a last timestamp equal to or after the given timestamp. \nFormats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours.\nExample: 2023-04-25T00:00:00Z, 2023-04-25, 2 days, 5 hours, 01 Mar 2023, 01 Feb 2023 04:45:33, 15 Jun."
      isArray: false
      name: last_timestamp
      required: false
      secret: false
    - default: false
      description: Filter by detection name.
      isArray: false
      name: detection_name
      required: false
      secret: false
    - default: false
      defaultValue: active
      description: Filter by state.
      isArray: false
      name: state
      required: false
      secret: false
    - default: false
      description: Filter by a tag or a comma-separated list of tags.
      isArray: false
      name: tags
      required: false
      secret: false
    deprecated: false
    description: Returns a list of detections for a specified entity.
    execution: false
    name: vectra-entity-detection-list
    outputs:
    - contextPath: Vectra.Entity.Detections.id
      description: Entity detection ID.
      type: Number
    - contextPath: Vectra.Entity.Detections.assigned_date
      description: Date assigned to the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.assigned_to
      description: User or entity assigned to the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.category
      description: Category of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.certainty
      description: Certainty level of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.c_score
      description: Confidence score of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.description
      description: Description of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.detection
      description: Detection information.
      type: String
    - contextPath: Vectra.Entity.Detections.detection_category
      description: Category of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.detection_type
      description: Type of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.external_target.ip
      description: IP address of the external target in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.external_target.name
      description: Name of the external target in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.num_sessions
      description: Number of sessions in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.bytes_received
      description: Total bytes received in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.bytes_sent
      description: Total bytes sent in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.ja3_hashes
      description: JA3 hashes in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.ja3s_hashes
      description: JA3S hashes in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.tunnel_type
      description: Tunnel type used in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.protocol
      description: Protocol used in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.app_protocol
      description: Application protocol used in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_port
      description: Destination port in the sessions of the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_ip
      description: Destination IP address in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.bytes_received
      description: Total bytes received in the sessions of the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.bytes_sent
      description: Total bytes sent in the sessions of the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.first_timestamp
      description: First timestamp of the sessions in the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.last_timestamp
      description: Last timestamp of the sessions in the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_geo
      description: Geolocation of the destination IP in the sessions of the detection group.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_geo_lat
      description: Latitude of the destination IP in the sessions of the detection group.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_geo_lon
      description: Longitude of the destination IP in the sessions of the detection group.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.grouped_details.first_timestamp
      description: First timestamp of the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.last_timestamp
      description: Last timestamp of the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.dst_ips
      description: Destination IP addresses in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.dst_ports
      description: Destination ports in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.target_domains
      description: Target domains in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.is_targeting_key_asset
      description: Indicates if the detection is targeting a key asset.
      type: Boolean
    - contextPath: Vectra.Entity.Detections.last_timestamp
      description: Last timestamp of the detection.
      type: Date
    - contextPath: Vectra.Entity.Detections.note
      description: Note associated with the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.note_modified_by
      description: User or entity who last modified the note.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.note_modified_timestamp
      description: Timestamp when the note was last modified.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.notes
      description: Additional notes related to the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.sensor_name
      description: Name of the sensor associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_account.id
      description: ID of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.name
      description: Name of the source account associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_account.url
      description: URL of the source account associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_account.threat
      description: Threat level of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.certainty
      description: Certainty level of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.privilege_level
      description: Privilege level of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.privilege_category
      description: Privilege category of the source account associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.id
      description: ID of the source host in the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_host.ip
      description: IP address of the source host in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.name
      description: Name of the source host in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.url
      description: URL associated with the source host in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.is_key_asset
      description: Indicates if the source host is a key asset.
      type: Boolean
    - contextPath: Vectra.Entity.Detections.src_host.groups
      description: Groups associated with the source host in the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.src_host.threat
      description: Threat level associated with the source host in the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_host.certainty
      description: Certainty level associated with the source host in the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_ip
      description: Source IP address in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.state
      description: State of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.summary.bytes_received
      description: Total bytes received in the detection summary.
      type: Number
    - contextPath: Vectra.Entity.Detections.summary.bytes_sent
      description: Total bytes sent in the detection summary.
      type: Number
    - contextPath: Vectra.Entity.Detections.summary.cnc_server
      description: CNC server associated with the detection summary.
      type: String
    - contextPath: Vectra.Entity.Detections.summary.num_events
      description: Total number of events related to the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.summary.probable_owner
      description: Probable owner of the detection summary.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.summary.sessions
      description: Total sessions in the detection summary.
      type: Number
    - contextPath: Vectra.Entity.Detections.tags
      description: Tags associated with the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.threat
      description: Threat level of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.t_score
      description: T-score of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.type
      description: Type of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.url
      description: URL associated with the detection.
      type: String
  - arguments:
    - default: false
      description: Specify the ID(s) of the detections.
      isArray: true
      name: detection_ids
      required: true
      secret: false
    - default: false
      defaultValue: '1'
      description: Enables the caller to specify a particular page of results.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: Specify the desired page size for the request. Maximum is 5000.
      isArray: false
      name: page_size
      required: false
      secret: false
    deprecated: false
    description: Returns a list of detections for the specified detection ID(s).
    execution: false
    name: vectra-detection-describe
    outputs:
    - contextPath: Vectra.Entity.Detections.id
      description: Entity detection ID.
      type: Number
    - contextPath: Vectra.Entity.Detections.assigned_date
      description: Date assigned to the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.assigned_to
      description: User or entity assigned to the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.category
      description: Category of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.certainty
      description: Certainty level of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.c_score
      description: Confidence score of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.description
      description: Description of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.detection
      description: Detection information.
      type: String
    - contextPath: Vectra.Entity.Detections.detection_category
      description: Category of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.detection_type
      description: Type of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.external_target.ip
      description: IP address of the external target in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.external_target.name
      description: Name of the external target in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.num_sessions
      description: Number of sessions in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.bytes_received
      description: Total bytes received in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.bytes_sent
      description: Total bytes sent in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.ja3_hashes
      description: JA3 hashes in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.ja3s_hashes
      description: JA3S hashes in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.tunnel_type
      description: Tunnel type used in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.protocol
      description: Protocol used in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.app_protocol
      description: Application protocol used in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_port
      description: Destination port in the sessions of the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_ip
      description: Destination IP address in the sessions of the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.bytes_received
      description: Total bytes received in the sessions of the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.bytes_sent
      description: Total bytes sent in the sessions of the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.first_timestamp
      description: First timestamp of the sessions in the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.last_timestamp
      description: Last timestamp of the sessions in the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_geo
      description: Geolocation of the destination IP in the sessions of the detection group.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_geo_lat
      description: Latitude of the destination IP in the sessions of the detection group.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.grouped_details.sessions.dst_geo_lon
      description: Longitude of the destination IP in the sessions of the detection group.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.grouped_details.first_timestamp
      description: First timestamp of the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.last_timestamp
      description: Last timestamp of the detection group.
      type: Date
    - contextPath: Vectra.Entity.Detections.grouped_details.dst_ips
      description: Destination IP addresses in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.grouped_details.dst_ports
      description: Destination ports in the detection group.
      type: Number
    - contextPath: Vectra.Entity.Detections.grouped_details.target_domains
      description: Target domains in the detection group.
      type: String
    - contextPath: Vectra.Entity.Detections.is_targeting_key_asset
      description: Indicates if the detection is targeting a key asset.
      type: Boolean
    - contextPath: Vectra.Entity.Detections.last_timestamp
      description: Last timestamp of the detection.
      type: Date
    - contextPath: Vectra.Entity.Detections.note
      description: Note associated with the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.note_modified_by
      description: User or entity who last modified the note.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.note_modified_timestamp
      description: Timestamp when the note was last modified.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.notes
      description: Additional notes related to the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.sensor_name
      description: Name of the sensor associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_account.id
      description: ID of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.name
      description: Name of the source account associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_account.url
      description: URL of the source account associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_account.threat
      description: Threat level of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.certainty
      description: Certainty level of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.privilege_level
      description: Privilege level of the source account associated with the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_account.privilege_category
      description: Privilege category of the source account associated with the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.id
      description: ID of the source host in the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_host.ip
      description: IP address of the source host in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.name
      description: Name of the source host in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.url
      description: URL associated with the source host in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.src_host.is_key_asset
      description: Indicates if the source host is a key asset.
      type: Boolean
    - contextPath: Vectra.Entity.Detections.src_host.groups
      description: Groups associated with the source host in the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.src_host.threat
      description: Threat level associated with the source host in the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_host.certainty
      description: Certainty level associated with the source host in the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.src_ip
      description: Source IP address in the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.state
      description: State of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.summary.bytes_received
      description: Total bytes received in the detection summary.
      type: Number
    - contextPath: Vectra.Entity.Detections.summary.bytes_sent
      description: Total bytes sent in the detection summary.
      type: Number
    - contextPath: Vectra.Entity.Detections.summary.cnc_server
      description: CNC server associated with the detection summary.
      type: String
    - contextPath: Vectra.Entity.Detections.summary.num_events
      description: Total number of events related to the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.summary.probable_owner
      description: Probable owner of the detection summary.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.summary.sessions
      description: Total sessions in the detection summary.
      type: Number
    - contextPath: Vectra.Entity.Detections.tags
      description: Tags associated with the detection.
      type: Unknown
    - contextPath: Vectra.Entity.Detections.threat
      description: Threat level of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.t_score
      description: T-score of the detection.
      type: Number
    - contextPath: Vectra.Entity.Detections.type
      description: Type of the detection.
      type: String
    - contextPath: Vectra.Entity.Detections.url
      description: URL associated with the detection.
      type: String
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      description: Note to be added in the specified entity_id.
      isArray: false
      name: note
      required: true
      secret: false
    deprecated: false
    description: Add a note to the entity.
    execution: false
    name: vectra-entity-note-add
    outputs:
    - contextPath: Vectra.Entity.Notes.entity_id
      description: ID of the entity associated with the note.
      type: String
    - contextPath: Vectra.Entity.Notes.note_id
      description: ID of the note.
      type: Number
    - contextPath: Vectra.Entity.Notes.date_created
      description: Date when the note was created.
      type: Date
    - contextPath: Vectra.Entity.Notes.date_modified
      description: Date when the note was last modified.
      type: Unknown
    - contextPath: Vectra.Entity.Notes.created_by
      description: User who created the note.
      type: String
    - contextPath: Vectra.Entity.Notes.modified_by
      description: User who last modified the note.
      type: Unknown
    - contextPath: Vectra.Entity.Notes.note
      description: Content of the note.
      type: String
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      description: Specify the ID of the note.
      isArray: false
      name: note_id
      required: true
      secret: false
    - default: false
      description: Note to be updated for the specified note_id.
      isArray: false
      name: note
      required: true
      secret: false
    deprecated: false
    description: Update a note in the entity.
    execution: false
    name: vectra-entity-note-update
    outputs:
    - contextPath: Vectra.Entity.Notes.entity_id
      description: ID of the entity associated with the note.
      type: String
    - contextPath: Vectra.Entity.Notes.note_id
      description: ID of the note.
      type: Number
    - contextPath: Vectra.Entity.Notes.date_created
      description: Date when the note was created.
      type: Date
    - contextPath: Vectra.Entity.Notes.date_modified
      description: Date when the note was last modified.
      type: Unknown
    - contextPath: Vectra.Entity.Notes.created_by
      description: User who created the note.
      type: String
    - contextPath: Vectra.Entity.Notes.modified_by
      description: User who last modified the note.
      type: Unknown
    - contextPath: Vectra.Entity.Notes.note
      description: Content of the note.
      type: String
  - arguments:
    - default: false
      description: Specify the ID of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      description: Specify the ID of the note.
      isArray: false
      name: note_id
      required: true
      secret: false
    deprecated: false
    description: Remove a note from the entity.
    execution: false
    name: vectra-entity-note-remove
  - arguments:
    - default: false
      description: Provide a list of detection IDs separated by commas or a single detection ID.
      isArray: false
      name: detection_ids
      required: true
      secret: false
    deprecated: false
    description: Mark detection as fixed with provided detection IDs in argument.
    execution: false
    name: vectra-detections-mark-fixed
  - arguments:
    - default: false
      description: Provide a list of detection IDs separated by commas or a single detection ID.
      isArray: false
      name: detection_ids
      required: true
      secret: false
    deprecated: false
    description: Unmark detection as fixed with provided detection IDs in argument.
    execution: false
    name: vectra-detections-unmark-fixed
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      description: Comma-separated values of tags to be included in the entity.
      isArray: true
      name: tags
      required: true
      secret: false
    deprecated: false
    description: Add tags in the entity.
    execution: false
    name: vectra-entity-tag-add
    outputs:
    - contextPath: Vectra.Entity.Tags.tag_id
      description: ID of the tag.
      type: String
    - contextPath: Vectra.Entity.Tags.entity_id
      description: ID of the entity associated with the tag.
      type: String
    - contextPath: Vectra.Entity.Tags.entity_type
      description: Type of the entity.
      type: String
    - contextPath: Vectra.Entity.Tags.tags
      description: A list of tags linked to an entity.
      type: Unknown
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      description: Comma-separated values of tags to be removed from the entity.
      isArray: true
      name: tags
      required: true
      secret: false
    deprecated: false
    description: Remove tags from the entity.
    execution: false
    name: vectra-entity-tag-remove
    outputs:
    - contextPath: Vectra.Entity.Tags.tag_id
      description: ID of the tag.
      type: String
    - contextPath: Vectra.Entity.Tags.entity_id
      description: ID of the entity associated with the tag.
      type: String
    - contextPath: Vectra.Entity.Tags.entity_type
      description: Type of the entity.
      type: String
    - contextPath: Vectra.Entity.Tags.tags
      description: A list of tags linked to an entity.
      type: Unknown
  - arguments:
    - default: false
      description: Specify the id of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    deprecated: false
    description: Returns a list of tags for a specified entity.
    execution: false
    name: vectra-entity-tag-list
    outputs:
    - contextPath: Vectra.Entity.Tags.tag_id
      description: ID of the tag.
      type: String
    - contextPath: Vectra.Entity.Tags.entity_id
      description: ID of the entity associated with the tag.
      type: String
    - contextPath: Vectra.Entity.Tags.entity_type
      description: Type of the entity.
      type: String
    - contextPath: Vectra.Entity.Tags.tags
      description: A list of tags linked to an entity.
      type: Unknown
  - arguments:
    - default: false
      description: Specify the ID of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    - default: false
      description: Specify the ID of the user.
      isArray: false
      name: user_id
      required: true
      secret: false
    deprecated: false
    description: Add an assignment for the entity.
    execution: false
    name: vectra-entity-assignment-add
    outputs:
    - contextPath: Vectra.Entity.Assignments.id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assignment_id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.id
      description: ID of the user who assigned the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.username
      description: Username of the user who assigned the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.date_assigned
      description: Date when the entity was assigned.
      type: Date
    - contextPath: Vectra.Entity.Assignments.date_resolved
      description: Date when the entity was resolved.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.assignment_id
      description: ID of the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.actor
      description: ID of the actor who performed the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.event_type
      description: Type of assignment event.
      type: String
    - contextPath: Vectra.Entity.Assignments.events.datetime
      description: Date of the assignment event.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.context.to
      description: ID of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_t_score
      description: Threat score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_c_score
      description: Certainty score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.outcome.id
      description: ID of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.builtin
      description: Whether the assignment outcome is builtin or not.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.user_selectable
      description: Whether the assignment outcome is user selectable or not.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.title
      description: Title of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.category
      description: Category of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.resolved_by.id
      description: ID of the user who resolved the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.resolved_by.username
      description: Username of the user who resolved the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.triaged_detections
      description: Number of detections that have been triaged for the entity.
      type: Unknown
    - contextPath: Vectra.Entity.Assignments.host_id
      description: ID of the host that the entity is associated with.
      type: Number
    - contextPath: Vectra.Entity.Assignments.account_id
      description: ID of the account that the entity is associated with.
      type: Unknown
    - contextPath: Vectra.Entity.Assignments.assigned_to.id
      description: ID of the user who is currently assigned to the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_to.username
      description: Username of the user who is currently assigned to the entity.
      type: String
  - arguments:
    - default: false
      description: Specify the ID of the assignment.
      isArray: false
      name: assignment_id
      required: true
      secret: false
    - default: false
      description: Specify the ID of the user.
      isArray: false
      name: user_id
      required: true
      secret: false
    deprecated: false
    description: Update an assignment in the entity.
    execution: false
    name: vectra-entity-assignment-update
    outputs:
    - contextPath: Vectra.Entity.Assignments.id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assignment_id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.id
      description: ID of the user who assigned the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.username
      description: Username of the user who assigned the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.date_assigned
      description: Date when the entity was assigned.
      type: Date
    - contextPath: Vectra.Entity.Assignments.date_resolved
      description: Date when the entity was resolved.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.assignment_id
      description: ID of the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.actor
      description: ID of the actor who performed the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.event_type
      description: Type of assignment event.
      type: String
    - contextPath: Vectra.Entity.Assignments.events.datetime
      description: Date of the assignment event.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.context.to
      description: ID of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.from
      description: ID of the entity that was assigned.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_t_score
      description: Threat score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_c_score
      description: Certainty score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.outcome.id
      description: ID of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.builtin
      description: Whether the assignment outcome is builtin or not.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.user_selectable
      description: Whether the assignment outcome is user selectable or not.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.title
      description: Title of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.category
      description: Category of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.resolved_by.id
      description: ID of the user who resolved the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.resolved_by.username
      description: Username of the user who resolved the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.triaged_detections
      description: Number of detections that have been triaged for the entity.
      type: Unknown
    - contextPath: Vectra.Entity.Assignments.host_id
      description: ID of the host that the entity is associated with.
      type: Number
    - contextPath: Vectra.Entity.Assignments.account_id
      description: ID of the account that the entity is associated with.
      type: Unknown
    - contextPath: Vectra.Entity.Assignments.assigned_to.id
      description: ID of the user who is currently assigned to the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_to.username
      description: Username of the user who is currently assigned to the entity.
      type: String
  - arguments:
    - default: false
      description: Specify the ID of the assignment.
      isArray: false
      name: assignment_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the Outcome for resolving an assignment in the entity. The custom outcome is allowed.
      isArray: false
      name: outcome
      predefined:
      - Benign True Positive
      - Malicious True Positive
      - False Positive
      required: true
      secret: false
    - default: false
      defaultValue: Updated by XSOAR.
      description: A note to be added for resolving an assignment in the entity.
      isArray: false
      name: note
      required: false
      secret: false
    - default: false
      description: Triage rule for resolving an assignment in the entity.
      isArray: false
      name: triage_as
      required: false
      secret: false
    - default: false
      description: Provide a list of detection IDs separated by commas or a single detection ID.
      isArray: false
      name: detection_ids
      required: false
      secret: false
    deprecated: false
    description: Resolve an assignment in the entity.
    execution: false
    name: vectra-entity-assignment-resolve
    outputs:
    - contextPath: Vectra.Entity.Assignments.id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assignment_id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.id
      description: ID of the user who assigned the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.username
      description: Username of the user who assigned the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.date_assigned
      description: Date when the entity was assigned.
      type: Date
    - contextPath: Vectra.Entity.Assignments.date_resolved
      description: Date when the entity was resolved.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.assignment_id
      description: ID of the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.actor
      description: ID of the actor who performed the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.event_type
      description: Type of the assignment event.
      type: String
    - contextPath: Vectra.Entity.Assignments.events.datetime
      description: Date of the assignment event.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.context.to
      description: ID of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_t_score
      description: Threat score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_c_score
      description: Certainty score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.triage_as
      description: Triage status of the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.events.context.triaged_detection_ids
      description: IDs of the detections that have been triaged for the entity.
      type: Array
    - contextPath: Vectra.Entity.Assignments.events.context.fixed_detection_ids
      description: IDs of the detections that have been fixed.
      type: Array
    - contextPath: Vectra.Entity.Assignments.events.context.created_rule_ids
      description: IDs of the rules that have been created for the entity.
      type: Array
    - contextPath: Vectra.Entity.Assignments.outcome.id
      description: ID of the assignment outcome.
      type: Number
    - contextPath: Vectra.Entity.Assignments.outcome.builtin
      description: Whether the assignment outcome is builtin or not.
      type: Boolean
    - contextPath: Vectra.Entity.Assignments.outcome.user_selectable
      description: Whether the assignment outcome is user selectable or not.
      type: Boolean
    - contextPath: Vectra.Entity.Assignments.outcome.title
      description: Title of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.category
      description: Category of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.resolved_by.id
      description: ID of the user who resolved the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.resolved_by.username
      description: Username of the user who resolved the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.triaged_detections
      description: Number of detections that have been triaged for the entity.
      type: Array
    - contextPath: Vectra.Entity.Assignments.host_id
      description: ID of the host that the entity is associated with.
      type: Number
    - contextPath: Vectra.Entity.Assignments.account_id
      description: ID of the account that the entity is associated with.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_to.id
      description: ID of the user who is currently assigned to the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_to.username
      description: Username of the user who is currently assigned to the entity.
      type: String
  - arguments:
    - default: false
      description: Specify the ID of the detection.
      isArray: false
      name: detection_id
      required: true
      secret: false
    deprecated: false
    description: Download pcap of the detection.
    execution: false
    name: vectra-detection-pcap-download
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: Number
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: The entry ID of the file.
      type: String
    - contextPath: File.Info
      description: File information.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The file extension.
      type: String
  - arguments:
    - default: false
      description: Specify the ID of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: true
      secret: false
    deprecated: false
    description: Mark the detections of the entity as fixed with the provided entity ID in the argument.
    execution: false
    name: vectra-entity-detections-mark-fixed
  - arguments:
    - default: false
      description: Specify the IDs of the entities. Comma-separated values supported.
      isArray: false
      name: entity_ids
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - account
      - host
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Filter by resolved status.
      isArray: false
      name: resolved
      predefined:
      - 'True'
      - 'False'
      required: false
      secret: false
    - default: false
      description: Filter by user ids of the assignment. Comma-separated values supported.
      isArray: false
      name: assignees
      required: false
      secret: false
    - default: false
      description: Filter by outcome ids of the resolution. Comma-separated values supported.
      isArray: false
      name: resolution
      required: false
      secret: false
    - default: false
      description: "Filter by created after the timestamp.\n\nSupported formats: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ.\n    \nFor example: 01 May 2023, 01 Mar 2021 04:45:33, 2022-04-17T14:05:44Z."
      isArray: false
      name: created_after
      required: false
      secret: false
    - default: false
      defaultValue: '1'
      description: Enables the caller to specify a particular page of results.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: Specify the desired page size for the request.
      isArray: false
      name: page_size
      required: false
      secret: false
    deprecated: false
    description: Returns a list of all assignments.
    execution: false
    name: vectra-assignment-list
    outputs:
    - contextPath: Vectra.Entity.Assignments.id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assignment_id
      description: ID of the assignment.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.id
      description: ID of the user who assigned the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_by.username
      description: Username of the user who assigned the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.date_assigned
      description: Date when the entity was assigned.
      type: Date
    - contextPath: Vectra.Entity.Assignments.date_resolved
      description: Date when the entity was resolved.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.assignment_id
      description: ID of the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.actor
      description: ID of the actor who performed the assignment event.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.event_type
      description: Type of the assignment event.
      type: String
    - contextPath: Vectra.Entity.Assignments.events.datetime
      description: Date of the assignment event.
      type: Date
    - contextPath: Vectra.Entity.Assignments.events.context.to
      description: ID of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_t_score
      description: Threat score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.entity_c_score
      description: Certainty score of the entity that was assigned to.
      type: Number
    - contextPath: Vectra.Entity.Assignments.events.context.triage_as
      description: Triage status of the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.events.context.triaged_detection_ids
      description: IDs of the detections that have been triaged for the entity.
      type: Array
    - contextPath: Vectra.Entity.Assignments.events.context.fixed_detection_ids
      description: IDs of the detections that have been fixed.
      type: Array
    - contextPath: Vectra.Entity.Assignments.events.context.created_rule_ids
      description: IDs of the rules that have been created for the entity.
      type: Array
    - contextPath: Vectra.Entity.Assignments.outcome.id
      description: ID of the assignment outcome.
      type: Number
    - contextPath: Vectra.Entity.Assignments.outcome.builtin
      description: Whether the assignment outcome is builtin or not.
      type: Boolean
    - contextPath: Vectra.Entity.Assignments.outcome.user_selectable
      description: Whether the assignment outcome is user selectable or not.
      type: Boolean
    - contextPath: Vectra.Entity.Assignments.outcome.title
      description: Title of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.outcome.category
      description: Category of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.resolved_by.id
      description: ID of the user who resolved the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.resolved_by.username
      description: Username of the user who resolved the entity.
      type: String
    - contextPath: Vectra.Entity.Assignments.triaged_detections
      description: Number of detections that have been triaged for the entity.
      type: Array
    - contextPath: Vectra.Entity.Assignments.host_id
      description: ID of the host that the entity is associated with.
      type: Number
    - contextPath: Vectra.Entity.Assignments.account_id
      description: ID of the account that the entity is associated with.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_to.id
      description: ID of the user who is currently assigned to the entity.
      type: Number
    - contextPath: Vectra.Entity.Assignments.assigned_to.username
      description: Username of the user who is currently assigned to the entity.
      type: String
  - arguments:
    - default: false
      defaultValue: '1'
      description: Enables the caller to specify a particular page of results.
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: Specify the desired page size for the request.
      isArray: false
      name: page_size
      required: false
      secret: false
    deprecated: false
    description: Returns a list of all entity assignment outcomes.
    execution: false
    name: vectra-assignment-outcome-list
    outputs:
    - contextPath: Vectra.Entity.Assignments.Outcomes.id
      description: ID of the assignment outcome.
      type: Number
    - contextPath: Vectra.Entity.Assignments.Outcomes.builtin
      description: Whether the assignment outcome is builtin or not.
      type: Boolean
    - contextPath: Vectra.Entity.Assignments.Outcomes.user_selectable
      description: Whether the assignment outcome is user selectable or not.
      type: Boolean
    - contextPath: Vectra.Entity.Assignments.Outcomes.title
      description: Title of the assignment outcome.
      type: String
    - contextPath: Vectra.Entity.Assignments.Outcomes.category
      description: Category of the assignment outcome.
      type: String
  - arguments:
    - default: false
      description: Specify the ID of the entity.
      isArray: false
      name: entity_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specify the type of the entity.
      isArray: false
      name: entity_type
      predefined:
      - host
      - account
      required: true
      secret: false
    deprecated: false
    description: Returns a list of notes for a specified entity.
    execution: false
    name: vectra-entity-note-list
    outputs:
    - contextPath: Vectra.Entity.Notes.note_id
      description: ID of the note.
      type: Number
    - contextPath: Vectra.Entity.Notes.id
      description: ID of the note.
      type: Number
    - contextPath: Vectra.Entity.Notes.date_created
      description: Date when the note was created.
      type: Date
    - contextPath: Vectra.Entity.Notes.date_modified
      description: Date when the note was last modified.
      type: Unknown
    - contextPath: Vectra.Entity.Notes.created_by
      description: User who created the note.
      type: String
    - contextPath: Vectra.Entity.Notes.modified_by
      description: User who last modified the note.
      type: Unknown
    - contextPath: Vectra.Entity.Notes.note
      description: Content of the note.
      type: String
    - contextPath: Vectra.Entity.Notes.entity_id
      description: ID of the entity associated with the note.
      type: String
    - contextPath: Vectra.Entity.Notes.entity_type
      description: Type of the entity associated with the note.
      type: String
  - arguments:
    - auto: PREDEFINED
      default: false
      description: Filter by group type.
      isArray: false
      name: group_type
      predefined:
      - account
      - host
      - ip
      - domain
      required: false
      secret: false
    - default: false
      description: |-
        Filter by Account Names. Supports comma-separated values.

        Note: Only valid when the group_type parameter is set to "account".
      isArray: true
      name: account_names
      required: false
      secret: false
    - default: false
      description: |-
        Filter by Domains. Supports comma-separated values.

        Note: Only valid when the group_type parameter is set to "domain".
      isArray: true
      name: domains
      required: false
      secret: false
    - default: false
      description: |-
        Filter by Host IDs. Supports comma-separated values.

        Note: Only valid when the group_type parameter is set to "host".
      isArray: true
      name: host_ids
      required: false
      secret: false
    - default: false
      description: |-
        Filter by Host Names. Supports comma-separated values.

        Note: Only valid when the group_type parameter is set to "host".
      isArray: true
      name: host_names
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Filter by group importance.
      isArray: false
      name: importance
      predefined:
      - high
      - medium
      - low
      - never_prioritize
      required: false
      secret: false
    - default: false
      description: |-
        Filter by IPs. Supports comma-separated values.

        Note: Only valid when the group_type parameter is set to "ip".
      isArray: true
      name: ips
      required: false
      secret: false
    - default: false
      description: Filter by group description.
      isArray: false
      name: description
      required: false
      secret: false
    - default: false
      description: |-
        Return only the groups which have a last modification timestamp equal to or after the given timestamp.

        Supported formats: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ.

        For example: 01 May 2023, 01 Mar 2023 04:45:33, 2023-04-17T14:05:44Z.
      isArray: false
      name: last_modified_timestamp
      required: false
      secret: false
    - default: false
      description: Filters by the user id who made the most recent modification to the group.
      isArray: false
      name: last_modified_by
      required: false
      secret: false
    - default: false
      description: Filters by group name.
      isArray: false
      name: group_name
      required: false
      secret: false
    deprecated: false
    description: Returns a list of all groups.
    execution: false
    name: vectra-group-list
    outputs:
    - contextPath: Vectra.Group.group_id
      description: ID of the group.
      type: Number
    - contextPath: Vectra.Group.id
      description: ID of the group.
      type: Number
    - contextPath: Vectra.Group.name
      description: Name of the group.
      type: String
    - contextPath: Vectra.Group.description
      description: Description of the group.
      type: String
    - contextPath: Vectra.Group.last_modified
      description: Date when the group was last modified.
      type: Date
    - contextPath: Vectra.Group.last_modified_by
      description: Name of the user who last modified the group
      type: String
    - contextPath: Vectra.Group.type
      description: Type of the group.
      type: String
    - contextPath: Vectra.Group.members
      description: Members of the group.
      type: Unknown
    - contextPath: Vectra.Group.members.id
      description: Entity ID of member.
      type: Number
    - contextPath: Vectra.Group.members.name
      description: Entity name of member.
      type: String
    - contextPath: Vectra.Group.members.is_key_asset
      description: Indicates key asset.
      type: Boolean
    - contextPath: Vectra.Group.members.url
      description: Entity URL of member.
      type: String
    - contextPath: Vectra.Group.members.uid
      description: Entity UID of member.
      type: String
    - contextPath: Vectra.Group.rules.triage_category
      description: Triage category of rule.
      type: String
    - contextPath: Vectra.Group.rules.id
      description: Id of the rule.
      type: Number
    - contextPath: Vectra.Group.rules.description
      description: Description of the rule.
      type: String
    - contextPath: Vectra.Group.importance
      description: Importance level of the group.
      type: String
    - contextPath: Vectra.Group.cognito_managed
      description: Whether the group is managed by Cognito or not.
      type: Boolean
  - arguments:
    - default: false
      description: Specify Group ID to unassign members.
      isArray: false
      name: group_id
      required: true
      secret: false
    - default: false
      description: "Member values based on the group type. Supports comma-separated values.\n\n Note: \nIf the group type is host, then the \"Host IDs\". \nIf the group type is account, then \"Account Names\".\nIf the group type is ip, then the list of \"IPs\".\nIf the group type is domain, then the list of \"Domains\" ."
      isArray: true
      name: members
      required: true
      secret: false
    deprecated: false
    description: Unassign members from the specified group.
    execution: false
    name: vectra-group-unassign
    outputs:
    - contextPath: Vectra.Group.group_id
      description: ID of the group.
      type: Number
    - contextPath: Vectra.Group.id
      description: ID of the group.
      type: Number
    - contextPath: Vectra.Group.name
      description: Name of the group.
      type: String
    - contextPath: Vectra.Group.description
      description: Description of the group.
      type: String
    - contextPath: Vectra.Group.last_modified
      description: Date when the group was last modified.
      type: Date
    - contextPath: Vectra.Group.last_modified_by
      description: Name of the user who last modified the group
      type: String
    - contextPath: Vectra.Group.type
      description: Type of the group.
      type: String
    - contextPath: Vectra.Group.members
      description: Members of the group.
      type: Unknown
    - contextPath: Vectra.Group.members.id
      description: Entity ID of member.
      type: Number
    - contextPath: Vectra.Group.members.name
      description: Entity name of member.
      type: String
    - contextPath: Vectra.Group.members.is_key_asset
      description: Indicates key asset.
      type: Boolean
    - contextPath: Vectra.Group.members.url
      description: Entity URL of member.
      type: String
    - contextPath: Vectra.Group.members.uid
      description: Entity UID of member.
      type: String
    - contextPath: Vectra.Group.rules.triage_category
      description: Triage category of rule.
      type: String
    - contextPath: Vectra.Group.rules.id
      description: Id of the rule.
      type: Number
    - contextPath: Vectra.Group.rules.description
      description: Description of the rule.
      type: String
  - arguments:
    - default: false
      description: Specify Group ID to assign members.
      isArray: false
      name: group_id
      required: true
      secret: false
    - default: false
      description: "Member values based on the group type. Supports comma-separated values.\n\n Note: \nIf the group type is host, then the \"Host IDs\". \nIf the group type is account, then \"Account Names\".\nIf the group type is ip, then the list of \"IPs\".\nIf the group type is domain, then the list of \"Domains\" ."
      isArray: true
      name: members
      required: true
      secret: false
    deprecated: false
    description: Assign members to the specified group.
    execution: false
    name: vectra-group-assign
    outputs:
    - contextPath: Vectra.Group.group_id
      description: ID of the group.
      type: Number
    - contextPath: Vectra.Group.id
      description: ID of the group.
      type: Number
    - contextPath: Vectra.Group.name
      description: Name of the group.
      type: String
    - contextPath: Vectra.Group.description
      description: Description of the group.
      type: String
    - contextPath: Vectra.Group.last_modified
      description: Date when the group was last modified.
      type: Date
    - contextPath: Vectra.Group.last_modified_by
      description: Name of the user who last modified the group
      type: String
    - contextPath: Vectra.Group.type
      description: Type of the group.
      type: String
    - contextPath: Vectra.Group.members
      description: Members of the group.
      type: Unknown
    - contextPath: Vectra.Group.members.id
      description: Entity ID of member.
      type: Number
    - contextPath: Vectra.Group.members.name
      description: Entity name of member.
      type: String
    - contextPath: Vectra.Group.members.is_key_asset
      description: Indicates key asset.
      type: Boolean
    - contextPath: Vectra.Group.members.url
      description: Entity URL of member.
      type: String
    - contextPath: Vectra.Group.members.uid
      description: Entity UID of member.
      type: String
    - contextPath: Vectra.Group.rules.triage_category
      description: Triage category of rule.
      type: String
    - contextPath: Vectra.Group.rules.id
      description: Id of the rule.
      type: Number
    - contextPath: Vectra.Group.rules.description
      description: Description of the rule.
      type: String
  dockerimage: demisto/python3:3.10.13.73190
  feed: false
  isfetch: true
  isremotesyncin: true
  isremotesyncout: true
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >
    register_module_line('VectraXDR', 'start', __line__())

    import copy

    from typing import Dict, Callable


    import requests.auth

    import urllib3

    from urllib.parse import urlparse, parse_qs


    from datetime import datetime

    from requests.models import Response






    # Disable insecure warnings

    urllib3.disable_warnings()


    """ CONSTANTS """


    DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"  # ISO8601 format with UTC, default in XSOAR

    STATUS_LIST_TO_RETRY = [429] + [i for i in range(500, 600)]

    OK_CODES = (200, 201, 204, 401)

    MAX_RETRIES = 3

    BACKOFF_FACTOR = 15

    FIRST_FETCH = '1 hour'

    MAX_PAGE = 1

    MAX_PAGE_SIZE = 50

    ENTITY_AND_DETECTION_MAX_PAGE_SIZE = 5000

    MAX_URGENCY_SCORE = 100

    MIN_URGENCY_SCORE = 0

    VALID_ENTITY_TYPE = ['account', 'host']

    VALID_GROUP_TYPE = ['account', 'host', 'ip', 'domain']

    VALID_IMPORTANCE_VALUE = ['high', 'medium', 'low', 'never_prioritize']

    VALID_ENTITY_STATE = ['active', 'inactive']

    DEFAULT_URGENCY_SCORE_LOW_THRESHOLD = 30

    DEFAULT_URGENCY_SCORE_MEDIUM_THRESHOLD = 50

    DEFAULT_URGENCY_SCORE_HIGH_THRESHOLD = 80

    MAX_MIRRORING_LIMIT = 5000

    MAX_OUTGOING_NOTE_LIMIT = 8000

    UTM_PIVOT = "?pivot=Vectra-XSOAR-1.0.0"

    DETECTION_CATEGORY_TO_ARG = {
        'Command & Control': 'command',
        'Botnet': 'botnet',
        'Reconnaissance': 'reconnaissance',
        'Lateral Movement': 'lateral',
        'Exfiltration': 'exfiltration',
        'Info': 'info'
    }

    ERRORS = {
        'INVALID_OBJECT': 'Failed to parse {} object from response: {}',
        'INVALID_URGENCY_SCORE_THRESHOLD': 'Invalid urgency score thresholds for severity mapping. Please ensure that the '
                                           'urgency score thresholds follow the correct order: '
                                           'urgency_score_low_threshold < urgency_score_medium_threshold < '
                                           'urgency_score_high_threshold.',
        'INVALID_COMMAND_ARG_VALUE': "Invalid '{}' value provided. Please ensure it is one of the values from the "
                                     "following options: {}.",
        'REQUIRED_ARGUMENT': "Please provide valid value of the '{}'. It is required field.",
        'INVALID_INTEGER_VALUE': "'{}' value must be a non-zero and positive integer value.",
        'INVALID_NUMBER': '"{}" is not a valid number',
        'INVALID_MAX_FETCH': 'Invalid Max Fetch: {}. Max Fetch must be a positive integer ranging from 1 to 200.',
        'INVALID_PAGE_SIZE': "Invalid 'page size' provided. Please ensure that the page size value is between 1 and 5000.",
        'TRIAGE_AS_REQUIRED_WITH_DETECTION_IDS': "'triage_as' argument must be provided when using the 'detection_ids' "
                                                 "argument. ",
        'INVALID_OUTCOME': "Invalid outcome value. Valid outcome values are: {}",
        'INVALID_SUPPORT_FOR_ARG': 'The argument "{}" must be set to "{}" when providing value for argument "{}".',
        'ENTITY_IDS_WITHOUT_TYPE': "When using the 'entity_ids' argument, 'entity_type' is required, and vice versa.",
    }

    ENDPOINTS = {
        'AUTH_ENDPOINT': '/oauth2/token',
        'USER_ENDPOINT': '/api/v3.3/users',
        'GROUP_ENDPOINT': '/api/v3.3/groups',
        'ENTITY_ENDPOINT': '/api/v3.3/entities',
        'DETECTION_ENDPOINT': '/api/v3.3/detections',
        'ADD_AND_LIST_ENTITY_NOTE_ENDPOINT': '/api/v3.3/entities/{}/notes',
        'UPDATE_AND_REMOVE_ENTITY_NOTE_ENDPOINT': '/api/v3.3/entities/{}/notes/{}',
        'ENTITY_TAG_ENDPOINT': '/api/v3.3/tagging/entity/{}',
        'ASSIGNMENT_ENDPOINT': '/api/v3.3/assignments',
        'UPDATE_ASSIGNMENT_ENDPOINT': '/api/v3.3/assignments/{}',
        'RESOLVE_ASSIGNMENT_ENDPOINT': '/api/v3.3/assignments/{}/resolve',
        'ASSIGNMENT_OUTCOME_ENDPOINT': '/api/v3.3/assignment_outcomes/',
        'DOWNLOAD_DETECTION_PCAP': '/api/v3.3/detections/{}/pcap'
    }

    USER_AGENT = 'VectraXDR-XSOAR-1.0.0'

    PAGE_SIZE = 200

    ENTITY_IMPORTANCE = {
        'low': 0,
        'medium': 1,
        'high': 2
    }

    ENTITY_IMPORTANCE_LABEL = {
        0: 'Low',
        1: 'Medium',
        2: 'High'
    }

    SEVERITY = {
        'low': 1,
        'medium': 2,
        'high': 3,
        'critical': 4
    }

    MIRROR_DIRECTION = {
        'Incoming': 'In',
        'Outgoing': 'Out',
        'Incoming And Outgoing': 'Both'
    }


    """ CLIENT CLASS """



    class VectraClient(BaseClient):
        """
        Client class to interact with the Vectra API.
        """

        def __init__(self, server_url: str, client_id: str, client_secret_key: str, verify: bool, proxy: bool):
            """
            Initializes the class instance.

            Args:
                server_url (str): The URL of the server.
                client_id (str): The client ID for authentication.
                client_secret_key (str): The client secret key for authentication.
                verify (bool): Indicates whether to verify the server's SSL certificate.
                proxy (bool): Indicates whether to use a proxy for the requests.
            """
            super().__init__(base_url=server_url, verify=verify, proxy=proxy)
            self.client_id = client_id
            self.client_secret_key = client_secret_key

            # Fetch cached integration context.
            integration_context = get_integration_context()
            self._token = integration_context.get("access_token") or self._generate_tokens()

        def http_request(self, method: str, url_suffix: str = '', params: Dict[str, Any] = None,
                         data: Dict[str, Any] = None, json_data: Dict[str, Any] = None, response_type: str = 'response',
                         **kwargs):
            """
            Makes an HTTP request to the server.

            Args:
                method (str): The HTTP method (e.g., GET, POST, PUT, DELETE).
                url_suffix (str): The URL suffix to be appended to the base URL. Defaults to an empty string.
                params (dict): Query parameters to be appended to the URL. Defaults to None.
                data (object): Data to be sent in the request body. Defaults to None.
                json_data (dict): JSON data to be sent in the request body. Defaults to None.
                response_type (str): The expected response type. Defaults to None.
                **kwargs: Additional keyword arguments.

            Returns:
                object: The response object or None.
            """
            # Set the headers for the request, including the User-Agent and Authorization.
            headers = {
                'User-Agent': USER_AGENT,
                'Authorization': f'Bearer {self._token}'
            }
            demisto.debug(f'Making API request at {method} {url_suffix} with params:{params} and body:{data or json_data}')
            # Make the HTTP request using the _http_request method, passing the necessary parameters.
            res = self._http_request(method=method, url_suffix=url_suffix, headers=headers, data=data, json_data=json_data,
                                     params=params, retries=MAX_RETRIES, status_list_to_retry=STATUS_LIST_TO_RETRY,
                                     ok_codes=OK_CODES, backoff_factor=BACKOFF_FACTOR, resp_type='response',
                                     raise_on_status=True, **kwargs)
            # If the response status code indicates an authentication issue (e.g., 401),
            # generate a new access token using the refresh token and retry the request.
            if res.status_code in [401]:
                demisto.debug('Handling status code 401 by generating a new token using the refresh token.')
                self._token = self._generate_access_token_using_refresh_token()
                return self.http_request(method=method, url_suffix=url_suffix, params=params, response_type=response_type,
                                         data=data, json_data=json_data, **kwargs)
            try:
                result = None
                if response_type == 'json':
                    result = res.json()
                if response_type == 'content':
                    result = res.content()
                if response_type == 'response':
                    result = res
                if response_type == 'text':
                    result = res.text
            except ValueError as exception:
                raise DemistoException(ERRORS['INVALID_OBJECT']  # type: ignore[str-bytes-safe]
                                       .format(response_type, res.content), exception, res)
            # If the success response is received, then return it.
            if res.status_code in [200, 201, 204]:
                return result
            # Return None if the response status code does not indicate success.
            return None

        def _generate_tokens(self) -> str:
            """
            Generates access tokens using client credentials.

            Returns:
                str: The access token.
            """
            demisto.info("Generating new access token.")

            payload = 'grant_type=client_credentials'
            auth = requests.auth.HTTPBasicAuth(self.client_id, self.client_secret_key)
            headers = {
                'User-Agent': USER_AGENT,
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json'
            }
            response = self._http_request(method='POST', url_suffix=ENDPOINTS['AUTH_ENDPOINT'], headers=headers,
                                          data=payload, auth=auth, retries=MAX_RETRIES, backoff_factor=BACKOFF_FACTOR,
                                          status_list_to_retry=STATUS_LIST_TO_RETRY, raise_on_status=True)

            access_token = response.get('access_token')
            refresh_token = response.get('refresh_token')
            set_integration_context({'access_token': access_token, 'refresh_token': refresh_token})
            return access_token

        def _generate_access_token_using_refresh_token(self) -> str:  # type: ignore
            """
            Generates a new access token using the refresh token.

            Returns:
                str: The access token.
            """
            context = get_integration_context()
            refresh_token = context.get('refresh_token')
            demisto.info("Generating new access token using refresh token.")

            payload = f'grant_type=refresh_token&refresh_token={refresh_token}'
            headers = {
                'User-Agent': USER_AGENT,
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json'
            }
            response = self._http_request(method='POST', url_suffix=ENDPOINTS['AUTH_ENDPOINT'], headers=headers,
                                          data=payload, ok_codes=OK_CODES, retries=MAX_RETRIES,
                                          backoff_factor=BACKOFF_FACTOR,
                                          raise_on_status=True, resp_type='response')
            if response.status_code in [401]:
                return self._generate_tokens()
            elif response.status_code in [200, 201]:
                access_token = response.json().get('access_token')
                # set new access token
                set_integration_context({'access_token': access_token, 'refresh_token': refresh_token})
                return access_token

        def list_users_request(self, username: Optional[str], role=Optional[str],
                               last_login_timestamp=Optional[datetime]) -> Dict:
            """
            List users.

            Args:
                username (Optional[str]): The optional username to filter with (default: None).
                role (Optional[str]): The optional user role to filter with (default: None).
                last_login_timestamp (Optional[str]): Filter users after the specified last login timestamp (default: None).

            Returns:
                Dict: Response from the API containing the users.
            """
            params = assign_params(username=username, role=role, last_login_gte=last_login_timestamp)
            return self.http_request(method='GET', url_suffix=ENDPOINTS['USER_ENDPOINT'], params=params,
                                     response_type='json')

        def list_entities_request(self, page: int = MAX_PAGE, page_size: int = MAX_PAGE_SIZE, is_prioritized: bool = None,
                                  entity_type: str = None, last_modified_timestamp: Optional[datetime] = None,
                                  last_detection_timestamp: Optional[datetime] = None,
                                  tags: str = None, ordering: str = None, state: str = 'active') -> Dict:
            """List entities.

            Args:
                page (int): The page number to retrieve (default: MAX_PAGE).
                page_size (int): The number of entities to retrieve per page (default: MAX_PAGE_SIZE).
                is_prioritized (bool): Filter entities by prioritization status (default: None).
                entity_type (str): Filter entities by type (default: None).
                last_modified_timestamp (str): Filter entities modified after the specified timestamp (default: None).
                last_detection_timestamp (str): Filter entities detected detection after the specified timestamp
                (default: None).
                tags (str): Filter entities by tags (default: None).
                ordering (str): Specify the ordering of the entities (default: None).
                state (str): Filter entities by state (default: 'active').

            Returns:
                Dict: Response from the API containing the list of entities.
            """
            params = assign_params(page=page, page_size=page_size, is_prioritized=is_prioritized, type=entity_type,
                                   last_modified_timestamp_gte=last_modified_timestamp,
                                   last_detection_timestamp_gte=last_detection_timestamp, tags=tags, state=state,
                                   ordering=ordering)
            entities = self.http_request(method='GET', url_suffix=ENDPOINTS['ENTITY_ENDPOINT'], params=params,
                                         response_type='json')
            return entities

        def get_entity_request(self, entity_id: int = None, entity_type: str = None) -> Dict:
            """Get entity by ID.

            Args:
                entity_id (int): The ID of the entity to retrieve.
                entity_type (str): Filter entity by type (default: None).

            Returns:
                Dict: Response from the API containing the entity information.
            """
            params = assign_params(type=entity_type)
            entity = self.http_request(method='GET', url_suffix="{}/{}".format(ENDPOINTS['ENTITY_ENDPOINT'], entity_id),
                                       params=params, response_type='json')
            return entity

        def list_detections_request(self, detection_category: str = None, detection_type: str = None, entity_id: int = None,
                                    page: int = None, page_size: int = None, last_timestamp: Optional[datetime] = None,
                                    tags: str = None, state: str = 'active', detection_name: str = None,
                                    ids: str = None) -> Dict:
            """
            List detections.

            Args:
                detection_category (str, optional): Filter by detection category.
                detection_type (str, optional): Filter by detection type.
                entity_id (int, optional): Filter by entity ID.
                page (int, optional): Page number of the results.
                page_size (int, optional): Number of results per page.
                last_timestamp (str, optional): Filter by last timestamp greater than or equal to the provided value.
                tags (str, optional): Filter by tags.
                state (str, optional): Filter by detection state.
                detection_name (str, optional): Filter by detection name.
                ids(str, optional): Filter by detections ids.

            Returns:
                Dict: Response from the API containing the list of detections.
            """
            params = assign_params(detection_category=detection_category, detection_type=detection_type,
                                   entity_id=entity_id,
                                   page=page, page_size=page_size, last_timestamp_gte=last_timestamp, tags=tags,
                                   state=state, detection=detection_name, id=ids)
            detections = self.http_request(method='GET', url_suffix=ENDPOINTS['DETECTION_ENDPOINT'], params=params,
                                           response_type='json')
            return detections

        def list_entity_note_request(self, entity_id: int = None, entity_type: str = None) -> Dict:
            """
            List entity notes.

            Args:
                entity_id (int): The ID of the entity to add the note to.
                entity_type (str): The type of the entity.

            Returns:
                Dict: Response from the API.
            """
            params = assign_params(type=entity_type)
            notes = self.http_request(method='GET',
                                      url_suffix=ENDPOINTS['ADD_AND_LIST_ENTITY_NOTE_ENDPOINT'].format(entity_id),
                                      params=params, response_type='json')
            return notes

        def add_entity_note_request(self, entity_id: int = None, entity_type: str = None, note: str = None) -> Dict:
            """
            Add a note to an entity.

            Args:
                entity_id (int): The ID of the entity to add the note to.
                entity_type (str): The type of the entity.
                note (str): The note to add.

            Returns:
                Dict: Response from the API containing the added note.
            """
            params = assign_params(type=entity_type)
            data = {'note': note}
            notes = self.http_request(method='POST',
                                      url_suffix=ENDPOINTS['ADD_AND_LIST_ENTITY_NOTE_ENDPOINT'].format(entity_id),
                                      params=params, data=data, response_type='json')
            return notes

        def update_entity_note_request(self, entity_id: int = None, entity_type: str = None, note: str = None,
                                       note_id: int = None) -> Dict:
            """
            Updates the note of an entity.

            Args:
                entity_id (int): The ID of the entity to update the note for.
                entity_type (str): The type of the entity.
                note (str): The updated note for the entity.
                note_id (int): The ID of the note to be updated.

            Returns:
                Dict: Response from the API containing the updated note details.
            """
            params = assign_params(type=entity_type)
            data = {'note': note}
            notes = self.http_request(method='PATCH',
                                      url_suffix=ENDPOINTS['UPDATE_AND_REMOVE_ENTITY_NOTE_ENDPOINT'].format(entity_id,
                                                                                                            note_id),
                                      params=params, data=data, response_type='json')
            return notes

        def remove_entity_note_request(self, entity_id: int = None, entity_type: str = None, note_id: int = None):
            """
            Removes a note from an entity.

            Args:
                entity_id (int): The ID of the entity to remove the note from.
                entity_type (str): The type of the entity.
                note_id (int): The ID of the note to be removed.

            Returns:
                Dict: Response from the API confirming the removal of the note.
            """
            params = assign_params(type=entity_type)
            res = self.http_request(method='DELETE',
                                    url_suffix=ENDPOINTS['UPDATE_AND_REMOVE_ENTITY_NOTE_ENDPOINT'].format(entity_id,
                                                                                                          note_id),
                                    params=params, response_type='response')
            return res

        def update_entity_tags_request(self, entity_id: int = None, entity_type: str = None, tags: List = None) -> Dict:
            """
            Update tags to an entity.

            Args:
                entity_id (int): The ID of the entity to add the tags to.
                entity_type (str): The type of the entity.
                tags (List): Tags to set for entity.

            Returns:
                Dict: Response from the API containing the updated tags.
            """
            params = assign_params(type=entity_type)
            data = {'tags': tags}
            res = self.http_request(method='PATCH', url_suffix=ENDPOINTS['ENTITY_TAG_ENDPOINT'].format(entity_id),
                                    params=params, json_data=data, response_type='json')
            return res

        def list_entity_tags_request(self, entity_id: int = None, entity_type: str = None) -> Dict:
            """
            List tags for the specified entity.

            Args:
                entity_id (int): The ID of the entity to add tags.
                entity_type (str): The type of the entity.

            Returns:
                Dict: Response from the API containing the tags.
            """
            params = assign_params(type=entity_type)
            res = self.http_request(method='GET', url_suffix=ENDPOINTS['ENTITY_TAG_ENDPOINT'].format(entity_id),
                                    params=params, response_type='json')
            return res

        def mark_or_unmark_detection_fixed_request(self, detection_ids: List[str], mark: str) -> Dict:
            """
            Mark or unmark detections as fixed.

            Args:
                detection_ids (List[str]): List of detection IDs to mark or unmark as fixed.
                mark (str): True to mark as fixed, False to unmark as fixed.

            Returns:
                Dict: Response from the API.

            Raises:
                ValueError: If detection_ids is empty.
            """

            data = {
                "detectionIdList": detection_ids,
                "mark_as_fixed": mark
            }

            res = self.http_request(method='PATCH', url_suffix=ENDPOINTS['DETECTION_ENDPOINT'], json_data=data,
                                    response_type='json')
            return res

        def list_assignments_request(self, account_ids: str = None, host_ids: str = None, resolution: str = None,
                                     resolved: bool = None, created_after: str = None,
                                     assignees: str = None, page: int = None, page_size: int = None) -> Dict:
            """
            Retrieve a list of assignments based on the provided account IDs and host IDs.

            Args:
                account_ids (str, optional): A string containing comma-separated account IDs to filter assignments.
                host_ids (str, optional): A string containing comma-separated host IDs to filter assignments.
                resolution (str, optional): The resolution status of the assignments.
                resolved (bool, optional): Whether the assignments are resolved (True) or unresolved (False).
                created_after (str, optional): Filter assignments created after this date and time.
                assignees (str, optional): A string containing comma-separated assignee usernames to filter assignments.
                page (int, optional): Page number of the results.
                page_size (int, optional): Number of results per page.

            Returns:
                dict: Response from the API.
            """
            params = assign_params(accounts=account_ids, hosts=host_ids, resolution=resolution, resolved=resolved,
                                   created_after=created_after, assignees=assignees, page=page, page_size=page_size)
            res = self.http_request(method='GET', url_suffix=ENDPOINTS['ASSIGNMENT_ENDPOINT'], params=params,
                                    response_type='json')
            return res

        def add_entity_assignment_request(self, assign_to_user_id: Optional[int] = None,
                                          assign_host_id: Optional[int] = None,
                                          assign_account_id: Optional[int] = None) -> Dict:
            """
            Send a request to add an entity assignment.

            Args:
                assign_to_user_id (str, optional): The ID of the user to whom the entity will be assigned.
                    Defaults to None.
                assign_host_id (str, optional): The ID of the host to which the entity will be assigned.
                    Defaults to None.
                assign_account_id (str, optional): The ID of the account to which the entity will be assigned.
                    Defaults to None.

            Returns:
                dict: A dictionary containing the response from the API call. The structure of the dictionary
                depends on the specific implementation of the API.
            """
            body = assign_params(assign_to_user_id=assign_to_user_id, assign_host_id=assign_host_id,
                                 assign_account_id=assign_account_id)
            res = self.http_request(method='POST', url_suffix=ENDPOINTS['ASSIGNMENT_ENDPOINT'], data=body,
                                    response_type='json')
            return res

        def update_entity_assignment_request(self, assign_to_user_id: Optional[int] = None,
                                             assignment_id: Optional[int] = None) -> Dict:
            """
            Send a request to update an existing entity assignment.

            Args:
                assign_to_user_id (Optional[int], optional): The ID of the user to whom the entity will be reassigned.
                    Defaults to None.
                assignment_id (Optional[int], optional): The ID of the assignment to be updated.
                    Defaults to None.

            Returns:
                dict: Response from the API.
            """
            body = assign_params(assign_to_user_id=assign_to_user_id)
            res = self.http_request(method='PUT', url_suffix=ENDPOINTS['UPDATE_ASSIGNMENT_ENDPOINT'].format(assignment_id),
                                    data=body, response_type='json')
            return res

        def resolve_entity_assignment_request(self, assignment_id: Optional[int] = None, outcome: int = None,
                                              note: str = "Updated by XSOAR.",
                                              triage_as: str = None, detection_ids=None) -> Dict:
            """
            Resolves an entity assignment.

            Args:
                assignment_id (str, optional): The ID of the assignment to resolve.
                outcome (int, optional): The outcome of the resolved assignment.
                note (str, optional): A note to add to the resolution (default is "Updated by XSOAR.").
                triage_as (str, optional): The triage status to set for the resolved assignment.
                detection_ids (List[str], optional): The IDs of detections associated with the assignment.

            Returns:
                dict: Response from the API.
            """
            body = assign_params(outcome=outcome, note=note, triage_as=triage_as, detection_ids=detection_ids)
            res = self.http_request(method='PUT', url_suffix=ENDPOINTS['RESOLVE_ASSIGNMENT_ENDPOINT'].format(assignment_id),
                                    data=body, response_type='json')
            return res

        def list_assignment_outcomes_request(self, page: int = None, page_size: int = None) -> Dict:
            """
            Send a request to retrieve a list of assignment outcomes.

            Args:
                page (int, optional): Page number of the results.
                page_size (int, optional): Number of results per page.

            Returns:
                dict: Response from the API.
            """
            params = assign_params(page=page, page_size=page_size)
            res = self.http_request(method='GET', url_suffix=ENDPOINTS['ASSIGNMENT_OUTCOME_ENDPOINT'], params=params,
                                    response_type='json')
            return res

        def download_detection_pcap_request(self, detection_id: str = None) -> Response:
            """
            Send a request to download the packet capture (PCAP) associated with a Vectra detection.

            Args:
                detection_id (str, optional): The ID of the detection for which the PCAP should be downloaded.

            Returns:
                Response: Response from the API.
            """
            res = self.http_request(method='GET', url_suffix=ENDPOINTS['DOWNLOAD_DETECTION_PCAP'].format(detection_id),
                                    response_type='response')
            return res

        def list_group_request(self, group_type: str, account_names: List[str], domains: List[str], host_ids: List[str],
                               host_names: List[str], importance: str, ips: List[str], description: str,
                               last_modified_timestamp: Optional[datetime], last_modified_by: str, group_name: str) -> Dict:
            """
            List groups as per the specified parameters.

            Args:
                group_type (str): Filter by group type.
                account_names (List[str]): Filter groups associated with accounts.
                domains (List[str]): Filter groups associated with domains.
                host_ids (List[str]): Filter groups associated with hosts.
                host_names (List[str]): Filter groups associated with hosts.
                importance (str): User defined group importance.
                ips (List[str]): Filter groups associated with ips.
                description (List[str]): Filter by group description.
                last_modified_timestamp (Optional[datetime]):
                    Filters for all groups modified on or after the given timestamp (GTE).
                last_modified_by (str): Filters groups by the user id who made the most recent modification.
                group_name (str): Filters by group name.

            Returns:
                Dict: Response from the API containing the tags.
            """
            params = assign_params(type=group_type, account_names=','.join(account_names), domains=','.join(domains),
                                   host_ids=','.join(host_ids), host_names=','.join(host_names), importance=importance,
                                   ips=','.join(ips), description=description, name=group_name,
                                   last_modified_timestamp=last_modified_timestamp, last_modified_by=last_modified_by)
            res = self.http_request(method='GET', url_suffix=ENDPOINTS['GROUP_ENDPOINT'], params=params,
                                    response_type='json')
            return res

        def get_group_request(self, group_id: int = None) -> Dict:
            """Get group by ID.

            Args:
                group_id (int): The ID of the group to retrieve.

            Returns:
                Dict: Response from the API containing the group information.
            """
            group = self.http_request(method='GET', url_suffix="{}/{}".format(ENDPOINTS['GROUP_ENDPOINT'], group_id),
                                      response_type='json')
            return group

        def update_group_members_request(self, group_id: int = None, members: List = None) -> Dict:
            """Update members in group.

            Args:
                group_id (int): The ID of the group to retrieve.
                members (List): The member list.

            Returns:
                Dict: Response from the API containing the group information.
            """
            body = {
                "members": members
            }
            group = self.http_request(method='PATCH', url_suffix="{}/{}".format(ENDPOINTS['GROUP_ENDPOINT'], group_id),
                                      json_data=body, response_type='json')
            return group


    """ HELPER FUNCTIONS """



    def validate_urgency_score(urgency_score: str, score_name: str) -> Optional[int]:
        """
        Validates the urgency score to ensure it falls within the valid range of 0 to 100.

        Args:
            urgency_score (str): The urgency score to validate.
            score_name (str): The name of the urgency score.

        Raises:
            ValueError: If the urgency score is outside the valid range.
        """
        score = arg_to_number(urgency_score, arg_name=score_name)
        if score < MIN_URGENCY_SCORE or score > MAX_URGENCY_SCORE:  # type: ignore
            raise ValueError(f"Please provide a valid {score_name} between 0 and 100.")
        return score


    def validate_configuration_parameters(params: Dict[str, Any]):
        """
        Validates the configuration parameters provided.

        Args:
            params (Dict[str, Any]): A dictionary containing the configuration parameters.

        Raises:
            ValueError: Raised when required parameters are missing or have invalid values.
        """
        fetch_time = params.get('first_fetch')
        max_fetch = params.get('max_fetch')
        urgency_score = params.get('urgency_score')
        urgency_score_low_threshold = params.get('urgency_score_low_threshold', '30').strip()
        urgency_score_medium_threshold = params.get('urgency_score_medium_threshold', '50').strip()
        urgency_score_high_threshold = params.get('urgency_score_high_threshold', '80').strip()

        # Validate empty values
        if not fetch_time:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('First Fetch Time'))
        if not max_fetch:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('Max Fetch'))
        # validate max_fetch
        max_fetch = arg_to_number(max_fetch, arg_name='Max Fetch', required=True)
        if max_fetch > 200 or max_fetch < 1:  # type: ignore
            raise ValueError(ERRORS['INVALID_MAX_FETCH'].format(max_fetch))
        # validate first_fetch parameter
        arg_to_datetime(fetch_time, arg_name='first_fetch', required=True)

        # validate urgency score
        if urgency_score:
            validate_urgency_score(urgency_score, 'urgency_score')  # type: ignore

        uslt = validate_urgency_score(urgency_score_low_threshold, 'urgency_score_low_threshold')  # type: ignore

        usmt = validate_urgency_score(urgency_score_medium_threshold, 'urgency_score_medium_threshold')  # type: ignore

        usht = validate_urgency_score(urgency_score_high_threshold, 'urgency_score_high_threshold')  # type: ignore

        # validating urgency score threshold
        if not (uslt < usmt < usht):  # type: ignore
            raise ValueError(ERRORS['INVALID_URGENCY_SCORE_THRESHOLD'])


    def validate_positive_integer_arg(value: Optional[Any], arg_name: str, required: bool = False) -> bool:
        """
        Validates whether the provided argument value is a valid positive integer.

        Args:
            value (int): The value to validate.
            arg_name (str): The name of the argument.
            required (bool): Flag indicating if the argument is required (default: False).

        Returns:
            bool: True if the value is a valid positive integer.

        Raises:
            ValueError: If the value is not a valid positive integer.
        """
        if required and not value:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format(arg_name))
        if value is not None and (not str(value).isdigit() or int(value) <= 0):
            raise ValueError(ERRORS['INVALID_INTEGER_VALUE'].format(arg_name))

        return True


    def validate_entity_list_command_args(args: Dict):
        """
        Validate the arguments for the entity_list command.

        Args:
            args (Dict): The arguments passed to the entity_list command.

        Raises:
            ValueError: If any of the arguments are invalid.

        Returns:
            None
        """
        entity_type = args.get('entity_type', '').lower()
        state = args.get('state', '').lower()
        page = args.get('page', '1')
        page_size = args.get('page_size', '50')
        # Validate entity_type value
        if entity_type and entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))

        # Validate state value
        if state and state not in VALID_ENTITY_STATE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('state', ', '.join(VALID_ENTITY_STATE)))

        validate_positive_integer_arg(page, arg_name='page')
        validate_positive_integer_arg(page_size, arg_name='page_size')
        if int(page_size) < 1 or int(page_size) > ENTITY_AND_DETECTION_MAX_PAGE_SIZE:
            raise ValueError(ERRORS['INVALID_PAGE_SIZE'])


    def validate_list_entity_detections_args(args: Dict[Any, Any]):
        """
        Validate the arguments for listing entity detections.

        Args:
             args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If the entity ID is not provided.
            ValueError: If the detection category is invalid.
            ValueError: If the page size is invalid.
        """
        entity_id = args.get('entity_id')
        entity_type = args.get('entity_type', '').lower()
        detection_category = args.get('detection_category')
        page = args.get('page', '1')
        page_size = args.get('page_size', '50')

        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)

        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))

        if detection_category and detection_category not in DETECTION_CATEGORY_TO_ARG.keys():
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('detection_category',
                                                                        ', '.join(DETECTION_CATEGORY_TO_ARG.keys())))

        validate_positive_integer_arg(value=page, arg_name='page')
        validate_positive_integer_arg(value=page_size, arg_name='page_size')
        if int(page_size) < 1 or int(page_size) > ENTITY_AND_DETECTION_MAX_PAGE_SIZE:
            raise ValueError(ERRORS['INVALID_PAGE_SIZE'])


    def validate_detection_describe_args(args: Dict[Any, Any]):
        """
        Validate the arguments for detection describe.

        Args:
             args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If the detection IDs are not provided.
            ValueError: If the page size is invalid.
        """
        detection_ids = args.get('detection_ids', '')
        page = args.get('page', '1')
        page_size = args.get('page_size', '50')

        detection_ids = argToList(detection_ids, transform=arg_to_number)
        found_valid_detection_ids = False
        for detection_id in detection_ids:
            if isinstance(detection_id, int):
                if detection_id < 1:
                    raise ValueError(ERRORS['INVALID_INTEGER_VALUE'].format('detection_ids'))
                found_valid_detection_ids = True
        if not found_valid_detection_ids:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('detection_ids'))

        validate_positive_integer_arg(value=page, arg_name='page')
        validate_positive_integer_arg(value=page_size, arg_name='page_size')
        if int(page_size) < 1 or int(page_size) > ENTITY_AND_DETECTION_MAX_PAGE_SIZE:
            raise ValueError(ERRORS['INVALID_PAGE_SIZE'])


    def validate_entity_note_list_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the entity list add command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        entity_type = args.get('entity_type', '').lower()
        entity_id = args.get('entity_id')
        # Validate entity_id value
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate entity_type value
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))


    def validate_entity_note_add_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the entity note add command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        entity_type = args.get('entity_type', '').lower()
        note = args.get('note')
        entity_id = args.get('entity_id')
        # Validate entity_id value
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate entity_type value
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))
        # Validate note value
        if not note:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('note'))


    def validate_entity_note_update_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the entity note update command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        entity_type = args.get('entity_type', '').lower()
        note = args.get('note')
        entity_id = args.get('entity_id')
        note_id = args.get('note_id')
        # Validate entity_id value
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate note_id value
        validate_positive_integer_arg(note_id, arg_name='note_id', required=True)
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))
        # Validate note value
        if not note:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('note'))


    def validate_entity_note_remove_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the entity note update command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        entity_type = args.get('entity_type', '').lower()
        entity_id = args.get('entity_id')
        note_id = args.get('note_id')
        # Validate entity_id value
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate note_id value
        validate_positive_integer_arg(note_id, arg_name='note_id', required=True)
        # Validate entity_type value
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type.lower() not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))


    def validate_entity_tag_add_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the entity tag add command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        validate_entity_tag_list_command_args(args)
        tags = argToList(args.get('tags', ''))
        # Validate Tags value
        if not [tag.strip() for tag in tags if isinstance(tag, str) and tag.strip()]:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('tags'))


    def validate_entity_tag_list_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the entity tag list command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        entity_type = args.get('entity_type', '').lower()
        entity_id = args.get('entity_id')
        # Validate entity_id value
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate entity_type value
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))


    def validate_detections_mark_and_unmark_args(detection_ids: List):
        """
        Validate the arguments for mark and unmark detections as fixed.

        Args:
            detection_ids (List[int]): The list of detection IDs.

        Raises:
            ValueError: If the detection IDs are empty or contain invalid values.
        """
        # Validate detection_ids
        if not detection_ids:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('detection_ids'))
        all(validate_positive_integer_arg(i, arg_name='detection_ids') for i in detection_ids)


    def validate_assignment_list_command_args(args: Dict):
        """
        Validate the arguments provided for the assignment list command.

        Args:
            args (Dict): A dictionary containing the arguments for the assignment list command.

        Raises:
            ValueError: If the provided entity_type is not one of the valid types.
            ValueError: If entity_ids are provided without an entity_type and vice-versa.
            ValueError: If page or page_size values are not positive integers.
        """
        entity_ids = args.get('entity_ids')
        entity_type = args.get('entity_type')
        page = args.get('page', '1')
        page_size = args.get('page_size', '50')
        # Validate entity type
        if entity_type and entity_type.lower() not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))
        # Validate entity ids without entity_type and vice-versa
        if (entity_ids and not entity_type) or (entity_type and not entity_ids):
            raise ValueError(ERRORS['ENTITY_IDS_WITHOUT_TYPE'])
        # Validate pagination
        validate_positive_integer_arg(value=page, arg_name='page')
        validate_positive_integer_arg(value=page_size, arg_name='page_size')


    def validate_entity_assignment_add_command_args(args: Dict):
        """
        Validate the arguments provided for adding an entity assignment.

        Args:
            args (Dict): A dictionary containing the arguments for adding an entity assignment.

        Raises:
            ValueError: If the provided entity_id or user_id is not a positive integer.
            ValueError: If the entity_type is missing or not one of the valid types.
        """
        entity_id = args.get('entity_id')
        entity_type = args.get('entity_type')
        user_id = args.get('user_id')
        # Validate entity_id value
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate note_id value
        validate_positive_integer_arg(user_id, arg_name='user_id', required=True)
        # Validate entity_type value
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type.lower() not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))


    def validate_entity_assignment_update_command_args(args: Dict):
        """
        Validate the arguments provided for updating an entity assignment.

        Args:
            args (Dict): A dictionary containing the arguments for updating an entity assignment.

        Raises:
            ValueError: If the provided assignment_id or user_id is not a positive integer.
        """
        assignment_id = args.get('assignment_id')
        user_id = args.get('user_id')
        # Validate assignment_id value
        validate_positive_integer_arg(assignment_id, arg_name='assignment_id', required=True)
        # Validate user_id value
        validate_positive_integer_arg(user_id, arg_name='user_id', required=True)


    def validate_entity_assignment_resolve_command_args(args):
        """
        Validate the arguments provided for resolving an entity assignment.

        Args:
            args (Dict): A dictionary containing the arguments for resolving an entity assignment.

        Raises:
            ValueError: If the provided assignment_id is not a positive integer.
            ValueError: If the outcome argument is missing.
            ValueError: If detection_ids are provided without triage_as.
        """
        outcome = args.get('outcome')
        assignment_id = args.get('assignment_id')
        triage_as = args.get('triage_as')
        detection_ids = args.get('detection_ids')
        # Validate assignment_id value
        validate_positive_integer_arg(assignment_id, arg_name='assignment_id', required=True)
        # Validate outcome value
        if not outcome:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('outcome'))
        if detection_ids and not triage_as:
            raise ValueError(ERRORS['TRIAGE_AS_REQUIRED_WITH_DETECTION_IDS'])


    def validate_entity_detections_mark_fix_command_args(args):
        """
        Validate the arguments provided for marking entity detections as fixed.

        Args:
            args (Dict): A dictionary containing the arguments for marking entity detections as fixed.

        Raises:
            ValueError: If the provided entity_id is not a positive integer.
            ValueError: If the entity_type is missing or not one of the valid types.
        """
        entity_id = args.get('entity_id')
        entity_type = args.get('entity_type')
        validate_positive_integer_arg(entity_id, arg_name="entity_id", required=True)

        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type and entity_type.lower() not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))


    def validate_group_list_command_args(args: Dict[Any, Any]):
        """
        Validates the arguments provided for the group list command.

        Args:
            args (dict[Any, Any]): The arguments dictionary.

        Raises:
            ValueError: If any of the arguments are invalid.
        """
        group_type = args.get('group_type') or ''
        if group_type:
            group_type = group_type.lower()
        # Validate group_type value
        if group_type and isinstance(group_type, str) and group_type.lower() not in VALID_GROUP_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('group_type', ', '.join(VALID_GROUP_TYPE)))

        importance = args.get('importance') or ''
        if importance:
            importance = importance.lower()
        # Validate importance value
        if importance and isinstance(importance, str) and importance.lower() not in VALID_IMPORTANCE_VALUE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('importance', ', '.join(VALID_IMPORTANCE_VALUE)))

        # Validate account_names value
        account_names = argToList(args.get('account_names') or '')
        if account_names and group_type != 'account':
            raise ValueError(ERRORS['INVALID_SUPPORT_FOR_ARG'].format('group_type', 'account', 'account_names'))

        # Validate domains value
        domains = argToList(args.get('domains') or '')
        if domains and group_type != 'domain':
            raise ValueError(ERRORS['INVALID_SUPPORT_FOR_ARG'].format('group_type', 'domain', 'domains'))

        # Validate host_ids value
        host_ids = argToList(args.get('host_ids') or '')
        if host_ids and group_type != 'host':
            raise ValueError(ERRORS['INVALID_SUPPORT_FOR_ARG'].format('group_type', 'host', 'host_ids'))
        for host_id in host_ids:
            host_id = arg_to_number(host_id, 'host_ids')
            if host_id < 1:
                raise ValueError(ERRORS['INVALID_INTEGER_VALUE'].format('host_ids'))

        # Validate host_names value
        host_names = argToList(args.get('host_names') or '')
        if host_names and group_type != 'host':
            raise ValueError(ERRORS['INVALID_SUPPORT_FOR_ARG'].format('group_type', 'host', 'host_names'))

        # Validate ips value
        ips = argToList(args.get('ips') or '')
        if ips and group_type != 'ip':
            raise ValueError(ERRORS['INVALID_SUPPORT_FOR_ARG'].format('group_type', 'ip', 'ips'))


    def validate_group_assign_and_unassign_command_args(args):
        """
        Validate the arguments provided for assigning or unassigning members to/from a group.

        Args:
            args (Dict): A dictionary containing the arguments for the group assign and unassign command.

        Raises:
            ValueError: If the provided group_id is not a positive integer.
            ValueError: If members argument is missing.
        """
        group_id = args.get('group_id')
        members = args.get('members')
        validate_positive_integer_arg(group_id, arg_name="group_id", required=True)

        if not members:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('members'))


    def urgency_score_to_severity(entity_urgency_score: Optional[int], urgency_score_lt: Optional[int],
                                  urgency_score_mt: Optional[int], urgency_score_ht: Optional[int]) -> int:
        """
        Maps the urgency score to severity levels.
        Demisto's severity levels are 4 - Critical, 3 - High, 2 - Medium, 1 - Low

        Args:
            entity_urgency_score(int): The urgency score to be mapped.
            urgency_score_lt(int): The urgency score threshold for low severity.
            urgency_score_mt(int): The urgency score threshold for medium severity.
            urgency_score_ht(int): The urgency score threshold for high severity.

        Returns
            severity(int):The corresponding severity level based on the urgency score.
        """
        if entity_urgency_score > urgency_score_ht:  # type: ignore
            return SEVERITY['critical']
        elif entity_urgency_score > urgency_score_mt:  # type: ignore
            return SEVERITY['high']
        elif entity_urgency_score > urgency_score_lt:  # type: ignore
            return SEVERITY['medium']
        else:
            return SEVERITY['low']


    def trim_spaces_from_args(args: Dict) -> Dict:
        """
        Trim spaces from values of the args Dict.

        Args:
            args (Dict): Dictionary to trim spaces from.

        Returns:
            Dict: Arguments after trim spaces.
        """
        for key, val in args.items():
            if isinstance(val, str):
                args[key] = val.strip()
            val_list = argToList(val)
            if len(val_list) > 1:
                val_list = [item for item in val_list if item.strip()]
                args[key] = ','.join(val_list)
        return args


    def calc_pages(total_count: int, per_page_count: int):
        """
        Calculates the number of pages required to display all the items,
        considering the number of items to be displayed per page

        Args:
            total_count (int): The total number of items.
            per_page_count (int): The count of items per page.

        Returns:
            int: The total number of pages.
        """
        return -(-total_count // per_page_count)


    def trim_api_version(url: str) -> str:
        """
        Trim the '/api/v3.3' portion from a URL.

        Args:
            url (str): The URL to trim.

        Returns:
            str: The trimmed URL.
        """
        api_versions = ["/api/v3.3", "/api/v3"]
        for api_version in api_versions:
            if api_version in url:
                trimmed_url = url.replace(api_version, "") + UTM_PIVOT
                return trimmed_url
        return url


    def get_mirroring():
        """
        Get the mirroring configuration parameters from the Demisto integration parameters.

        Returns:
            dict: A dictionary containing the mirroring configuration parameters.
        """
        params = demisto.params()
        mirror_direction = params.get('mirror_direction', 'None').strip()
        mirror_tags = params.get('note_tag', '').strip()
        return {
            'mirror_direction': MIRROR_DIRECTION.get(mirror_direction),
            'mirror_tags': mirror_tags,
            'mirror_instance': demisto.integrationInstance()
        }


    def get_user_list_command_hr(users: List):
        """
        Converts a list of users into a human-readable table format.

        Args:
            users (Dict): The list of entities to convert.

        Returns:
            str: The human-readable table in Markdown format.
        """
        hr_dict = []
        # Process detection_set and create detection_ids field
        for user in users:  # type: ignore
            user["user_id"] = user["id"]
            hr_dict.append({
                "User ID": user.get('user_id'),
                "User Name": user.get('username'),
                "Email": user.get('email'),
                "Role": user.get('role'),
                "Last Login Timestamp": user.get('last_login_timestamp'),
            })
        # Prepare human-readable output table
        human_readable = tableToMarkdown("Users Table", hr_dict,
                                         ['User ID', 'User Name', 'Email', 'Role', 'Last Login Timestamp'], removeNull=True)

        return human_readable


    def get_entity_list_command_hr(entities: Dict, page: int, page_size: int, count: int):
        """
        Converts a list of entities into a human-readable table format.

        Args:
            entities (Dict): The list of entities to convert.
            page (int): The current page number.
            page_size (int): The page size.
            count (int): The total count of entities.

        Returns:
            str: The human-readable table in Markdown format.
        """
        hr_dict = []
        entity_list = copy.deepcopy(entities)
        # Process detection_set and create detection_ids field
        for entity in entity_list:  # type: ignore
            # Trim API version from url
            entity['url'] = trim_api_version(entity.get('url'))
            # Convert ID into clickable URL
            entity['id_url'] = f"[{entity['id']}]({entity['url']})"
            # Map entity importance
            entity['importance'] = ENTITY_IMPORTANCE_LABEL[entity.get('importance')]
            if 'detection_set' in entity:
                entity['detection_ids'] = ', '.join(
                    ["[{}]({})".format(detection.split('/')[-1], trim_api_version(detection)) for detection in
                     entity.get('detection_set')])
            hr_dict.append({
                "ID": entity.get('id_url'),
                "Name": entity.get('name'),
                "Entity Type": entity.get('type'),
                "Urgency Score": entity.get('urgency_score'),
                "Entity Importance": entity.get('importance'),
                "Last Modified Timestamp": entity.get('last_modified_timestamp'),
                "Last Detection Timestamp": entity.get('last_detection_timestamp'),
                "Detections IDs": entity.get('detection_ids'),
                "Prioritize": entity.get('is_prioritized'),
                "State": entity.get('state'),
                "Tags": ', '.join(entity.get('tags')) if entity.get('tags') else None,
            })
        # Prepare human-readable output table
        pages = calc_pages(per_page_count=page_size, total_count=count)  # type: ignore
        human_readable = tableToMarkdown(f"Entities Table (Showing Page {page} out of {pages})",
                                         hr_dict,
                                         ['ID', 'Name', 'Entity Type', 'Urgency Score', 'Entity Importance',
                                          'Last Detection Timestamp', 'Last Modified Timestamp', 'Detections IDs',
                                          'Prioritize', 'State', 'Tags'],
                                         removeNull=True)

        return human_readable


    def get_entity_get_command_hr(entity: Dict):
        """
        Returns the human-readable output for the entity details.

        Args:
            entity (Dict): The entity details dictionary.

        Returns:
            str: The human-readable output.
        """
        hr_dict = []
        entity_res = copy.deepcopy(entity)
        # Trim API version from entity url
        entity_res['url'] = trim_api_version(entity_res.get('url'))  # type: ignore
        entity_res['id'] = f"[{entity_res['id']}]({entity_res['url']})"

        # Process detection_set and create detection_ids field
        if 'detection_set' in entity_res:
            entity_res['detection_ids'] = ', '.join(
                ["[{}]({})".format(detection.split('/')[-1], trim_api_version(detection)) for detection in
                 entity_res.get('detection_set')])  # type: ignore
        # Entity importance value to label
        entity_res['importance'] = ENTITY_IMPORTANCE_LABEL[entity_res.get('importance')]  # type: ignore
        hr_dict.append({
            "Name": entity_res.get('name'),
            "Entity Type": entity_res.get('type'),
            "Urgency Score": entity_res.get('urgency_score'),
            "Entity Importance": entity_res.get('importance'),
            "Last Modified Timestamp": entity_res.get('last_modified_timestamp'),
            "Last Detection Timestamp": entity_res.get('last_detection_timestamp'),
            "Detections IDs": entity_res.get('detection_ids'),
            "Prioritize": entity_res.get('is_prioritized'),
            "State": entity_res.get('state'),
            "Tags": ', '.join(entity_res.get('tags')) if entity_res.get('tags') else None,  # type: ignore
        })

        # Prepare human-readable output table
        human_readable = tableToMarkdown(f"Entity detail:\n#### Entity ID: {entity_res.get('id')}", hr_dict,
                                         ['Name', 'Entity Type', 'Urgency Score', 'Entity Importance',
                                          'Last Detection Timestamp', 'Last Modified Timestamp', 'Detections IDs',
                                          'Prioritize', 'State', 'Tags'],
                                         removeNull=True)
        return human_readable


    def get_list_entity_detections_command_hr(detections: Dict[Any, Any], page: Optional[int], page_size: Optional[int],
                                              count: int):
        """
        Converts the list of detections into a human-readable table format.

        Args:
            detections (Dict): Dictionary containing the list of detections.
            page (int): The current page number.
            page_size (int): The page size.
            count (int): The total count of detections.

        Returns:
            str: Human-readable table representation of the detections.
        """
        hr_dict = []
        detection_list = copy.deepcopy(detections)
        # Process detection_set and create detection_ids field
        for detection in detection_list:  # type: ignore
            # Trim API version from url
            detection['url'] = trim_api_version(detection.get('url'))
            # Convert ID into clickable URL
            detection['id'] = f"[{detection['id']}]({detection['url']})"
            account_url = None
            if detection.get('src_account'):
                account_url = f"[{detection.get('src_account').get('name')}]" \
                              f"({trim_api_version(detection.get('src_account').get('url'))})"
            if detection.get('src_host'):
                host_url = f"[{detection.get('src_host').get('name')}]" \
                           f"({trim_api_version(detection.get('src_host').get('url'))})"
            else:
                host_url = None
            summary = detection.get('summary')
            num_events = 0
            # For counting number of events
            if summary and summary.get('num_events'):
                num_events = int(summary.get('num_events'))

            hr_dict.append({
                'ID': detection.get('id'),
                'Detection Name': detection.get('detection'),
                'Detection Type': detection.get('detection_type'),
                'Category': detection.get('category'),
                'Account Name': account_url,
                'Host Name': host_url,
                'Src IP': detection.get('src_ip'),
                'Threat Score': detection.get('threat'),
                'Certainty Score': detection.get('certainty'),
                'Number Of Events': num_events,
                'State': detection.get('state'),
                'Tags': detection.get('tags'),
                'Last Timestamp': detection.get('last_timestamp')
            })
            pages = calc_pages(per_page_count=page_size, total_count=count)  # type: ignore
        human_readable = tableToMarkdown(f"Detections Table (Showing Page {page} out of {pages})", hr_dict,
                                         ['ID', 'Detection Name', 'Detection Type', 'Category', 'Account Name', 'Host Name',
                                          'Src IP', 'Threat Score', 'Certainty Score', 'Number Of Events', 'State', 'Tags',
                                          'Last Timestamp'],
                                         removeNull=True)

        return human_readable


    def get_assignment_list_command_hr(assignments: Dict, page: Optional[int], page_size: Optional[int],
                                       count: int):
        """
        Returns the human-readable output for the assignment.

        Args:
            assignments(Dict): The assignment details dictionary.
            page (int): The current page number.
            page_size (int): The page size.
            count (int): The total count of assignments.

        Returns:
            str: The human-readable output.
        """
        hr_dict = []
        for assignment in assignments:
            assignment['assignment_id'] = assignment['id']
            hr_dict.append({
                'Account ID': assignment.get('account_id'),
                'Host ID': assignment.get('host_id'),
                'Assignment ID': assignment.get('id'),
                'Assigned By': assignment.get('assigned_by', {}).get('username', ''),
                'Assigned To': assignment.get('assigned_to', {}).get('username', ''),
                'Date Assigned': assignment.get('date_assigned'),
                'Resolved By': assignment.get('resolved_by', {}).get('username', ''),
                'Date Resolved': assignment.get('date_resolved'),
                'Outcome ID': assignment.get('outcome', {}).get('id', ''),
                'Outcome': assignment.get('outcome', {}).get('title', ''),
            })
        pages = calc_pages(per_page_count=page_size, total_count=count)  # type: ignore
        human_readable = tableToMarkdown(f"Assignments Table (Showing Page {page} out of {pages})", hr_dict,
                                         ['Account ID', 'Host ID', 'Assignment ID', 'Assigned By', 'Assigned To',
                                          'Date Assigned', 'Resolved By', 'Date Resolved', 'Outcome ID', 'Outcome'],
                                         removeNull=True)
        return human_readable, assignments


    def entity_assignment_add_command_hr(assignment: Dict) -> str:
        """
        Returns the human-readable output for the assignment.

        Args:
            assignment (Dict): The assignment details dictionary.

        Returns:
            str: The human-readable output.
        """
        assigned_by = assignment.get('assigned_by', {})
        assigned_to = assignment.get('assigned_to', {})
        events = assignment.get('events', [{}])
        hr_dict = [{
            "Assignment ID": assignment.get('assignment_id'),
            "Assigned By": assigned_by.get('username') if isinstance(assigned_by, dict) else '',
            "Assigned Date": assignment.get('date_assigned'),
            "Assigned To": assigned_to.get('username') if isinstance(assigned_to, dict) else '',
            "Event Type": events[0].get('event_type') if isinstance(events, list) and len(events) > 0 else '',
        }]

        # Prepare human-readable output table
        human_readable = tableToMarkdown("Assignment detail", hr_dict,
                                         ['Assignment ID', 'Assigned By', 'Assigned Date', 'Assigned To', 'Event Type'],
                                         removeNull=True)
        return human_readable


    def get_assignment_outcome_list_command_hr(outcomes: Dict, page: Optional[int], page_size: Optional[int],
                                               count: int):
        """
        Returns the human-readable output for the assignment outcome list.

        Args:
            outcomes(Dict): The assignment outcomes list dictionary.
            page (int): The current page number.
            page_size (int): The page size.
            count (int): The total count of outcomes.

        Returns:
            str: The human-readable output.
            dict: Outcomes dictionary
        """
        hr_dict = []
        for outcome in outcomes:
            outcome['outcome_id'] = outcome['id']
            hr_dict.append({
                "Outcome ID": outcome.get('id'),
                "Built IN": outcome.get('builtin'),
                "User Selectable": outcome.get('user_selectable'),
                "Title": outcome.get('title'),
                "Category": outcome.get('category'),
            })
        pages = calc_pages(per_page_count=page_size, total_count=count)  # type: ignore
        # Prepare human-readable output table
        human_readable = tableToMarkdown(f"Assignment Outcomes Table (Showing Page {page} out of {pages})", hr_dict,
                                         ['Outcome ID', 'Title', 'Category', 'Built IN', 'User Selectable'],
                                         removeNull=True)
        return human_readable, outcomes


    def get_list_entity_notes_command_hr(notes: Dict, entity_id: Optional[int], entity_type: str) -> str:
        """
        Returns the human-readable output for the entity notes.

        Args:
            notes (Dict): The assignment details dictionary.
            entity_id (Optional[int]): Entity ID.
            entity_type (str): Entity Type.

        Returns:
            str: The human-readable output.
        """
        hr_dict = []
        for note in notes:
            note['note_id'] = note['id']
            note.update({'entity_id': entity_id, 'entity_type': entity_type})

            hr_dict.append({
                "Note ID": note.get('id'),
                "Note": note.get('note'),
                "Created By": note.get('created_by'),
                "Created Date": note.get('date_created'),
                "Modified By": note.get('modified_by'),
                "Modified Date": note.get('date_modified'),
            })

        # Prepare human-readable output table
        human_readable = tableToMarkdown("Entity Notes Table", hr_dict,
                                         ['Note ID', 'Note', 'Created By', 'Created Date', 'Modified By', 'Modified Date'],
                                         removeNull=True)
        return human_readable


    def get_group_list_command_hr(groups: List):
        """
        Converts a list of groups into a human-readable table format.

        Args:
            groups (Dict): The list of groups to convert.

        Returns:
            str: The human-readable table in Markdown format.
        """
        hr_dict = []
        # Process members data from group and make HR for groups
        for group in groups:  # type: ignore
            group["group_id"] = group["id"]
            members: List = group.get('members')
            members_hr = None
            if members and isinstance(members, list):
                # If the members are simple list of strings, then join them with comma.
                if isinstance(members[0], str):
                    members_hr = ', '.join([re.escape(str(member)) for member in members])
                # If the members are list of dictionaries, then extract important field from that and join it with comma.
                elif isinstance(members[0], dict):
                    members_list = []
                    for member in members:
                        if member.get('uid'):
                            members_list.append(re.escape(str(member.get('uid'))))  # type: ignore
                        elif member.get('id'):
                            members_list.append(  # type: ignore
                                "[{}]({})".format(member.get('id'), trim_api_version(member.get('url'))))
                    members_hr = ', '.join(members_list)

            hr_dict.append({
                "Group ID": group.get('group_id'),
                "Name": group.get('name'),
                "Group Type": group.get('type'),
                "Description": group.get('description'),
                "Importance": group.get('importance'),
                "Members": members_hr,
                "Last Modified Timestamp": group.get('last_modified'),
            })
        # Prepare human-readable output table
        human_readable = tableToMarkdown("Groups Table", hr_dict,
                                         ['Group ID', 'Name', 'Group Type', 'Description', 'Importance', 'Members',
                                          'Last Modified Timestamp'], removeNull=True)

        return human_readable


    def get_group_unassign_and_assign_command_hr(group: Dict, changed_members: List, assign_flag: bool = False):
        """
        Converts group into a human-readable table format.

        Args:
            group (Dict): The group to convert.
            changed_members (List): Removed/Added members from the group.
            assign_flag (bool): True for unassigning members, False for assigning members.

        Returns:
            str: The human-readable table in Markdown format.
        """
        hr_dict = []
        group["group_id"] = group["id"]
        members = group.get('members')
        members_hr = None
        if members and isinstance(members, list):
            # If the members are simple list of strings, then join them with comma.
            if isinstance(members[0], str):
                members_hr = ', '.join([re.escape(str(member)) for member in members])
            # If the members are list of dictionaries, then extract important field from that and join it with comma.
            elif isinstance(members[0], dict):
                members_list = []
                for member in members:
                    if member.get('uid'):
                        members_list.append(re.escape(str(member.get('uid'))))  # type: ignore
                    elif member.get('id'):
                        members_list.append(  # type: ignore
                            "[{}]({})".format(member.get('id'), trim_api_version(member.get('url'))))
                members_hr = ', '.join(members_list)

        hr_dict.append({
            "Group ID": group.get('group_id'),
            "Name": group.get('name'),
            "Group Type": group.get('type'),
            "Description": group.get('description'),
            "Members": members_hr,
            "Last Modified Timestamp": group.get('last_modified'),
        })

        # Prepare human-readable output table
        change_action = "assigned to" if assign_flag else "unassigned from"
        changed_members = [re.escape(member) for member in changed_members]
        human_readable = tableToMarkdown(
            f"Member(s) {', '.join(changed_members)} have been {change_action} the group.\n### Updated group details:",
            hr_dict, ['Group ID', 'Name', 'Group Type', 'Description', 'Members',
                      'Last Modified Timestamp'], removeNull=True)

        return human_readable


    """ COMMAND FUNCTIONS """



    def fetch_incidents(client: VectraClient, params: Dict[str, Any]) -> List:
        """
        Fetches incidents from the Vectra server.

        Args:
            client (VectraClient): Vectra client object.
            params (Dict[str, Any]): Fetch incidents parameters.

        Returns:
            List[Dict[str, Any]]: List of fetched incidents.
        """

        # Fetch parameters from the integration configuration
        first_fetch_time = params.get('first_fetch', FIRST_FETCH).strip()
        max_fetch_ = arg_to_number(params.get('max_fetch', str(MAX_PAGE_SIZE)).strip(), arg_name='Max Fetch', required=True)
        # Ensure max_fetch is not greater than 200
        if max_fetch_ < 1:  # type: ignore
            raise ValueError(ERRORS["INVALID_MAX_FETCH"].format(max_fetch_))
        if max_fetch_ > 200:  # type: ignore
            demisto.debug(f'The max fetch value is {max_fetch_}, which is greater than the maximum allowed value '
                          'of 200. Setting it to 200.')
        max_fetch = min(200, max_fetch_)  # type: ignore
        # Default page is 1
        page = MAX_PAGE
        # Retrieve last run data from the previous execution
        last_run = json.loads(demisto.getLastRun().get('value', '{}'))

        # Retrieve and preprocess entity_type parameter
        entity_type = params.get('entity_type', '')
        if isinstance(entity_type, list):
            entity_type = ','.join(entity_type).lower()
        else:
            entity_type = entity_type.lower()

        # Process is_prioritized parameter
        is_prioritized = params.get('is_prioritized', '')
        if not is_prioritized:
            is_prioritized = None
        else:
            is_prioritized = argToBoolean(is_prioritized.lower())

        # Fetch and process tags parameter
        tags = params.get('tags', '').strip()

        # Fetch detection_category and detection_type parameters
        detection_category = params.get('detection_category', '')
        detection_type = params.get('detection_type', '').strip()

        try:
            urgency_score_lt = validate_urgency_score(urgency_score=params.get('urgency_score_low_threshold', '30').strip(),
                                                      score_name='urgency_score_lt')
        except ValueError:
            demisto.error(
                'Provided urgency_score_low_threshold is not a valid number. Falling back to default threshold value 30.')
            urgency_score_lt = DEFAULT_URGENCY_SCORE_LOW_THRESHOLD

        try:
            urgency_score_mt = validate_urgency_score(
                urgency_score=params.get('urgency_score_medium_threshold', '50').strip(),
                score_name='urgency_score_mt')
        except ValueError:
            demisto.error(
                'Provided urgency_score_medium_threshold is not a valid number. Falling back to default threshold value 50.')
            urgency_score_mt = DEFAULT_URGENCY_SCORE_MEDIUM_THRESHOLD

        try:
            urgency_score_ht = validate_urgency_score(
                urgency_score=params.get('urgency_score_high_threshold', '80').strip(),
                score_name='urgency_score_ht')
        except ValueError:
            demisto.error(
                'Provided urgency_score_high_threshold is not a valid number. Falling back to default threshold value 80.')
            urgency_score_ht = DEFAULT_URGENCY_SCORE_HIGH_THRESHOLD

        if not last_run:  # If it's the first time running
            # Create a new last run object with the first fetch time
            new_last_run = {
                'time': arg_to_datetime(first_fetch_time, arg_name='First Fetch Time'
                                        ).strftime(DATE_FORMAT)  # type: ignore
            }
            demisto.debug(f'No last run object found, creating new last run object with value: {json.dumps(new_last_run)}')
        else:
            # Use the last run object from the previous run
            new_last_run = last_run
            demisto.debug('Using the last run object obtained from the previous run.')

        # Retrieve the from_timestamp from the new last run object
        from_timestamp = new_last_run.get('time')

        # Initialize the demisto_incidents list
        demisto_incidents: List = []

        # Retrieve the page number from the last run object or use the default value of 1
        next_url_last_run = last_run.get('next_url')
        if next_url_last_run:
            # Parse the URL
            parsed_url = urlparse(next_url_last_run)
            # Extract the query parameters
            query_params = parse_qs(parsed_url.query)
            page = arg_to_number(query_params.get('page', [''])[0], arg_name='page')  # type: ignore
            max_fetch = arg_to_number(query_params.get('page_size', [''])[0], arg_name='max_fetch')
            entity_type = query_params.get('type', [''])[0]
            is_prioritized = query_params.get('is_prioritized', [''])[0]
            if is_prioritized:
                is_prioritized = argToBoolean(is_prioritized)
            from_timestamp = query_params.get('last_modified_timestamp_gte', [''])[0]
            tags = query_params.get('tags', [''])[0]

        # Fetch the entities list from the server using the provided parameters
        response = client.list_entities_request(page=page, page_size=max_fetch, entity_type=entity_type,  # type: ignore
                                                is_prioritized=is_prioritized,
                                                last_modified_timestamp=from_timestamp,  # type: ignore
                                                tags=tags, ordering='last_modified_timestamp')

        # Retrieve the next page URL for pagination
        next_url = response.get('next')
        # Get the entities from the response
        entities = response.get('results')

        # Retrieve the already fetched IDs from the last run
        already_fetched = last_run.get('already_fetched', [])

        # Extract the IDs to check from the current response
        ids_to_check = [f"{item['id']}-{item['type']}" for item in response['results']]

        # Check if entities exist and not all IDs to check are already fetched
        if entities and not all(id_to_check in already_fetched for id_to_check in ids_to_check):
            # Iterate over each entity in the entities list
            for entity in entities:
                # Retrieve entity details
                detection_set = entity.get('detection_set', [])
                entity_id = entity.get('id')
                entity_name = entity.get('name')
                entity_type = entity.get('type')
                last_modified_timestamp = entity.get('last_modified_timestamp')
                entity_urgency_score = entity.get('urgency_score')
                entity_checkpoint = f"{entity_id}-{entity_type}"

                # Check if the entity has detections
                if len(detection_set) != 0:
                    detections_ids = ','.join([url.split("/")[-1] for url in detection_set])
                    # Fetch detections data using detections API call
                    detections_data = client.list_detections_request(detection_type=detection_type,
                                                                     detection_category=detection_category,
                                                                     ids=detections_ids)
                    detections = detections_data.get('results', [])
                    # Add detection details to the entity
                    entity.update({'detection_details': detections})

                # Fetch entity assignment
                if entity_type == 'account':
                    response = client.list_assignments_request(account_ids=entity_id)
                elif entity_type == 'host':
                    response = client.list_assignments_request(host_ids=entity_id)
                assignment_details = response.get('results', [])
                assignment_details = assignment_details[0] if len(assignment_details) > 0 else assignment_details
                entity.update({'assignment_details': assignment_details})
                # Add configuration filter
                entity.update({'filter_tags': tags})

                # Create an incident if the entity is not already fetched
                if entity_checkpoint not in already_fetched:
                    # Updating mirroring fields
                    mirroring_fields = get_mirroring()
                    mirroring_fields.update({'mirror_id': str(entity_id) + '-' + entity_type})
                    entity.update(mirroring_fields)

                    incident_name = f'Vectra XDR Entity {entity_name}:{entity_id}'
                    # Calculate severity based on urgency score using the urgency_score_to_severity function
                    severity = urgency_score_to_severity(entity_urgency_score, urgency_score_lt, urgency_score_mt,
                                                         # type: ignore
                                                         urgency_score_ht)

                    demisto_incidents.append({
                        'name': incident_name,
                        'occurred': last_modified_timestamp,
                        'rawJSON': json.dumps(entity),
                        'severity': severity
                    })
                    already_fetched.append(entity_checkpoint)

            # Update the last run object with the latest timestamp and page information if incidents were found
            if len(entities) == max_fetch and next_url:
                new_last_run.update({
                    'next_url': next_url,
                    'already_fetched': already_fetched
                })
            else:
                new_last_run.update({
                    'time': entities[-1].get('last_modified_timestamp'),
                    'next_url': None,
                    'already_fetched': already_fetched
                })
        else:
            # If no incidents were found, update the last run object with the current time and reset the page to 1
            now = datetime.now().strftime(DATE_FORMAT)
            new_last_run.update({'page': 1, 'time': now})
        # Save the new last run object
        demisto.setLastRun({'value': json.dumps(new_last_run)})

        return demisto_incidents


    def vectra_user_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        Retrieves a list of users from the Vectra API.

        Args:
            client (VectraClient): The Vectra API client.
            args (Dict[str, Any]): Function arguments.

        Returns:
            CommandResults: The command results containing the entities.
        """
        last_login_timestamp = arg_to_datetime(args.get('last_login_timestamp'), arg_name='last_login_timestamp')
        if last_login_timestamp:
            last_login_timestamp = last_login_timestamp.strftime(DATE_FORMAT)  # type: ignore
        username = args.get('username', '')
        role = args.get('role', '')
        # Call Vectra API to retrieve users
        response = client.list_users_request(username=username, role=role, last_login_timestamp=last_login_timestamp)
        count = response.get('count')
        if count == 0:
            return CommandResults(outputs={}, readable_output="##### Got the empty list of users.", raw_response=response)
        users = response.get('results')

        # Prepare context data
        human_readable = get_user_list_command_hr(users)  # type: ignore
        context = [createContext(user) for user in remove_empty_elements(users)]  # type: ignore

        return CommandResults(outputs_prefix='Vectra.User', outputs=context,
                              readable_output=human_readable, raw_response=users, outputs_key_field=['user_id'])


    def vectra_entity_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        Retrieves a list of entities from the Vectra API.

        Args:
            client (VectraClient): The Vectra API client.
            args (Dict[str, Any]): Function arguments.

        Returns:
            CommandResults: The command results containing the entities.

        Raises:
            ValueError: If an invalid entity_type or state value is provided.
        """
        # Validate command args
        validate_entity_list_command_args(args)

        # Get function arguments
        entity_type = args.get('entity_type', '').lower()
        last_detection_timestamp = arg_to_datetime(args.get('last_detection_timestamp'),
                                                   arg_name='last_detection_timestamp')
        last_modified_timestamp = arg_to_datetime(args.get('last_modified_timestamp'),
                                                  arg_name='last_modified_timestamp')
        if last_detection_timestamp:
            last_detection_timestamp = last_detection_timestamp.strftime(DATE_FORMAT)  # type: ignore
        if last_modified_timestamp:
            last_modified_timestamp = last_modified_timestamp.strftime(DATE_FORMAT)  # type: ignore
        ordering = args.get('ordering', '')
        page = arg_to_number(args.get('page', '1'), arg_name='page')
        page_size = arg_to_number(args.get('page_size', '50'), arg_name='page_size')
        prioritized = args.get('prioritized', '')
        if prioritized:
            prioritized = argToBoolean(prioritized)
        state = args.get('state', '')
        tags = args.get('tags', '')

        # Call Vectra API to retrieve entities
        response = client.list_entities_request(entity_type=entity_type,
                                                last_detection_timestamp=last_detection_timestamp,
                                                last_modified_timestamp=last_modified_timestamp,
                                                ordering=ordering, page=page, page_size=page_size,  # type: ignore
                                                is_prioritized=prioritized,
                                                state=state, tags=tags)
        count = response.get('count')
        if count == 0:
            return CommandResults(outputs={},
                                  readable_output="##### Couldn't find any matching entities for provided filters.",
                                  raw_response=response)
        entities = response.get('results')

        # Prepare context data
        human_readable = get_entity_list_command_hr(entities, page, page_size, count)  # type: ignore
        context = [createContext(entity) for entity in remove_empty_elements(entities)]  # type: ignore

        return CommandResults(outputs_prefix='Vectra.Entity', outputs=context,
                              readable_output=human_readable, raw_response=entities, outputs_key_field=['id', 'type'])


    def vectra_entity_describe_command(client: VectraClient, args: Dict[str, Any]):
        """
        Describes an entity from the Vectra API.

        Args:
            client (VectraClient): The Vectra API client.
            args (Dict[str, Any]): Function arguments.

        Returns:
            CommandResults: The command results containing the entity.

        Raises:
            ValueError: If an invalid entity_type is provided.
        """
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id")
        entity_type = args.get('entity_type', '').lower()

        # Validate entity_id
        validate_positive_integer_arg(entity_id, arg_name='entity_id', required=True)
        # Validate entity_type value
        if not entity_type:
            raise ValueError(ERRORS['REQUIRED_ARGUMENT'].format('entity_type'))
        if entity_type not in VALID_ENTITY_TYPE:
            raise ValueError(ERRORS['INVALID_COMMAND_ARG_VALUE'].format('entity_type', ', '.join(VALID_ENTITY_TYPE)))

        # Call Vectra API to retrieve entity
        entity = client.get_entity_request(entity_id=entity_id, entity_type=entity_type)  # type: ignore

        human_readable = get_entity_get_command_hr(entity)

        return CommandResults(outputs_prefix='Vectra.Entity', outputs=createContext(remove_empty_elements(entity)),
                              readable_output=human_readable, raw_response=entity, outputs_key_field=['id', 'type'])


    def vectra_entity_detection_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        Retrieves a list of entity detections from the Vectra API.

        Args:
            client (VectraClient): The Vectra API client.
            args (Dict[str, Any]): Function arguments.

        Returns:
            CommandResults: The command results containing the entity detections.

        Raises:
            ValueError: If an invalid entity_type or state value is provided.
        """
        # Validation for args
        validate_list_entity_detections_args(args)

        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id")
        entity_type = args.get('entity_type', '').lower()
        detection_category = args.get('detection_category')
        detection_type = args.get('detection_type')
        detection_name = args.get('detection_name')
        state = args.get('state', 'active')
        tags = args.get('tags')
        last_timestamp = arg_to_datetime(args.get('last_timestamp'), arg_name='last_timestamp')
        if last_timestamp:
            last_timestamp = last_timestamp.strftime(DATE_FORMAT)  # type: ignore
        page = arg_to_number(args.get('page', '1'), arg_name="page")
        page_size = arg_to_number(args.get('page_size', '50'), arg_name="page_size")
        if detection_category:
            detection_category = DETECTION_CATEGORY_TO_ARG[detection_category]

        entity = client.get_entity_request(entity_id=entity_id, entity_type=entity_type)
        detection_set = entity.get('detection_set', [])
        detections_ids = ','.join([url.split("/")[-1] for url in detection_set]) if detection_set else ''
        if len(detections_ids) == 0:
            return CommandResults(outputs={}, readable_output="##### Couldn't find any matching detections for "
                                                              "provided entity ID and type.", raw_response={})
        # Call Vectra API to retrieve entities
        response = client.list_detections_request(ids=detections_ids, page=page, page_size=page_size,
                                                  detection_category=detection_category,
                                                  detection_type=detection_type, detection_name=detection_name,
                                                  last_timestamp=last_timestamp, state=state, tags=tags)
        count = response.get('count', 0)
        if count == 0:
            return CommandResults(outputs={},
                                  readable_output="##### Couldn't find any matching entity detections for "
                                                  "provided filters.", raw_response=response)
        detections = response.get('results', {})
        # Remove empty elements from the response
        # Prepare HR
        hr = get_list_entity_detections_command_hr(detections, page, page_size, count)
        # Create context
        context = [createContext(remove_empty_elements(detection)) for detection in detections]  # type: ignore

        return CommandResults(outputs_prefix='Vectra.Entity.Detections', outputs=context,
                              readable_output=hr, raw_response=response, outputs_key_field='id')


    def vectra_detection_describe_command(client: VectraClient, args: Dict[str, Any]):
        """
        Describes a list of detections for provided detection IDs from the Vectra API.

        Args:
            client (VectraClient): The Vectra API client.
            args (Dict[str, Any]): Function arguments.

        Returns:
            CommandResults: The command results containing the detections.

        Raises:
            ValueError: If an invalid detection_ids or page value is provided.
        """
        # Validation for args
        validate_detection_describe_args(args)

        # Get function arguments
        detection_ids = argToList(args.get('detection_ids'), transform=arg_to_number)
        detection_ids = [detection_id for detection_id in detection_ids if isinstance(detection_id, int)]
        page = arg_to_number(args.get('page', '1'), arg_name="page")
        page_size = arg_to_number(args.get('page_size', '50'), arg_name="page_size")
        # Call Vectra API to retrieve entities
        response = client.list_detections_request(ids=','.join([str(detection_id) for detection_id in detection_ids]),
                                                  state='', page=page, page_size=page_size)
        count = response.get('count', 0)
        if count == 0:
            return CommandResults(outputs={},
                                  readable_output="##### Couldn't find any matching detections for "
                                                  "provided detection ID(s).", raw_response=response)
        detections = response.get('results', {})
        # Prepare HR
        hr = get_list_entity_detections_command_hr(detections, page, page_size, count)
        # Create context
        context = [createContext(remove_empty_elements(detection)) for detection in detections]  # type: ignore

        return CommandResults(outputs_prefix='Vectra.Entity.Detections', outputs=context,
                              readable_output=hr, raw_response=response, outputs_key_field='id')


    def vectra_entity_note_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        List entity notes.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_note_list_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()

        # Call Vectra API to add entity note
        notes = client.list_entity_note_request(entity_id=entity_id, entity_type=entity_type)  # type: ignore
        notes = remove_empty_elements(notes)
        if notes:
            human_readable = get_list_entity_notes_command_hr(notes, entity_id, entity_type)

            context = [createContext(note) for note in notes]

            return CommandResults(outputs_prefix='Vectra.Entity.Notes', outputs=context,
                                  readable_output=human_readable, raw_response=notes,
                                  outputs_key_field=['entity_id', 'entity_type', 'note_id'])
        else:
            return CommandResults(outputs={},
                                  readable_output="##### Couldn't find any notes for provided entity.",
                                  raw_response=notes)


    def vectra_entity_note_add_command(client: VectraClient, args: Dict[str, Any]):
        """
        Adds a note to an entity in Vectra API.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_note_add_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()
        note = args.get('note')

        # Call Vectra API to add entity note
        notes = client.add_entity_note_request(entity_id=entity_id, entity_type=entity_type, note=note)  # type: ignore
        if notes:
            notes['note_id'] = notes['id']
            notes.update({'entity_id': entity_id, 'entity_type': entity_type})

        human_readable = "##### The note has been successfully added to the entity."
        human_readable += f"\nReturned Note ID: **{notes['note_id']}**"

        return CommandResults(outputs_prefix='Vectra.Entity.Notes', outputs=createContext(remove_empty_elements(notes)),
                              readable_output=human_readable, raw_response=notes,
                              outputs_key_field=['entity_id', 'entity_type', 'note_id'])


    def vectra_entity_note_update_command(client: VectraClient, args: Dict[str, Any]):
        """
        Updates a note to an entity in Vectra API.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_note_update_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()
        note = args.get('note')
        note_id = arg_to_number(args.get('note_id'), arg_name="note_id", required=True)

        # Call Vectra API to update entity note
        notes = client.update_entity_note_request(entity_id=entity_id, entity_type=entity_type, note=note,
                                                  note_id=note_id)  # type: ignore
        if notes:
            notes['note_id'] = notes['id']
            notes.update({'entity_id': entity_id, 'entity_type': entity_type})

        human_readable = "##### The note has been successfully updated in the entity."

        return CommandResults(outputs_prefix='Vectra.Entity.Notes', outputs=createContext(remove_empty_elements(notes)),
                              readable_output=human_readable, raw_response=notes,
                              outputs_key_field=['entity_id', 'entity_type', 'note_id'])


    def vectra_entity_note_remove_command(client: VectraClient, args: Dict[str, Any]):
        """
        Updates a note to an entity in Vectra API.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_note_remove_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()
        note_id = arg_to_number(args.get('note_id'), arg_name="note_id", required=True)

        # Call Vectra API to remove note
        response = client.remove_entity_note_request(entity_id=entity_id, entity_type=entity_type,
                                                     note_id=note_id)  # type: ignore
        if response.status_code == 204:
            human_readable = "##### The note has been successfully removed from the entity."
        else:
            human_readable = "Something went wrong."
        return CommandResults(outputs={}, readable_output=human_readable)


    def vectra_entity_tag_add_command(client: VectraClient, args: Dict[str, Any]):
        """
        Add tags to an entity.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_tag_add_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()
        tags = [tag.strip() for tag in argToList(args.get('tags', '')) if isinstance(tag, str) and tag.strip()]

        # Call Vectra API to get existing entity tags
        existing_tag_res = client.list_entity_tags_request(entity_id=entity_id, entity_type=entity_type)  # type: ignore
        existing_tag_res_status = existing_tag_res.get('status', '')
        if not existing_tag_res_status or not isinstance(existing_tag_res_status,
                                                         str) or existing_tag_res_status.lower() != 'success':
            message = 'Something went wrong.'
            if existing_tag_res.get('message'):
                message += f" Message: {existing_tag_res.get('message')}."
            raise DemistoException(message)
        tags_resp = existing_tag_res.get('tags', [])
        tags = list(dict.fromkeys(tags_resp + tags))

        res = existing_tag_res
        if len(dict.fromkeys(tags_resp)) != len(tags):
            # Call Vectra API to add entity tags
            res = client.update_entity_tags_request(entity_id=entity_id, entity_type=entity_type, tags=tags)  # type: ignore
            res_status = res.get('status', '')
            if not res_status or not isinstance(res_status, str) or res_status.lower() != 'success':
                message = 'Something went wrong.'
                if res.get('message'):
                    message += f" Message: {res.get('message')}."
                raise DemistoException(message)

        human_readable = '##### Tags have been successfully added to the entity.'
        tags_resp = res.get('tags', [])
        if tags_resp and isinstance(tags_resp, list):
            tags_resp = [tag.strip() for tag in tags_resp if isinstance(tag, str) and tag.strip()]
            if tags_resp:
                tags_resp = f'**{"**, **".join(tags_resp)}**'
                human_readable += f'\nUpdated list of tags: {tags_resp}'

        res['entity_type'] = entity_type
        res['entity_id'] = entity_id
        del res['status']

        return CommandResults(outputs_prefix='Vectra.Entity.Tags', outputs=createContext(remove_empty_elements(res)),
                              readable_output=human_readable, raw_response=res,
                              outputs_key_field=['tag_id', 'entity_type', 'entity_id'])


    def vectra_entity_tag_remove_command(client: VectraClient, args: Dict[str, Any]):
        """
        Removes associated tags for the specified entity using Vectra API.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_tag_add_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()
        input_tags = [tag.strip() for tag in argToList(args.get('tags', '')) if isinstance(tag, str) and tag.strip()]

        # Call Vectra API to get existing entity tags
        existing_tag_res = client.list_entity_tags_request(entity_id=entity_id, entity_type=entity_type)  # type: ignore
        existing_tag_res_status = existing_tag_res.get('status', '')
        if not existing_tag_res_status or not isinstance(existing_tag_res_status,
                                                         str) or existing_tag_res_status.lower() != 'success':
            message = 'Something went wrong.'
            if existing_tag_res.get('message'):
                message += f" Message: {existing_tag_res.get('message')}."
            raise DemistoException(message)
        tags_resp = existing_tag_res.get('tags', [])
        # Filtering set of tags from existing tags response with the provide set of input tags
        updated_tags = [tag_resp.strip() for tag_resp in tags_resp if tag_resp.strip() not in input_tags]

        res = existing_tag_res
        # Only update tags if there is any update required with the specified tags
        if len(dict.fromkeys(tags_resp)) != len(updated_tags):
            # Call Vectra API to update entity tags
            res = client.update_entity_tags_request(
                entity_id=entity_id, entity_type=entity_type, tags=updated_tags)  # type: ignore
            res_status = res.get('status', '')
            if not res_status or not isinstance(res_status, str) or res_status.lower() != 'success':
                message = 'Something went wrong.'
                if res.get('message'):
                    message += f" Message: {res.get('message')}."
                raise DemistoException(message)

        human_readable = '##### Specified tags have been successfully removed for the entity.'
        tags_resp = res.get('tags', [])
        if tags_resp and isinstance(tags_resp, list):
            tags_resp = [tag.strip() for tag in tags_resp if isinstance(tag, str) and tag.strip()]
            if tags_resp:
                tags_resp = f'**{"**, **".join(tags_resp)}**'
                human_readable += f'\nUpdated list of tags: {tags_resp}'

        res['entity_type'] = entity_type
        res['entity_id'] = entity_id
        del res['status']

        return CommandResults(outputs_prefix='Vectra.Entity.Tags', outputs=createContext(remove_empty_elements(res)),
                              readable_output=human_readable, raw_response=res,
                              outputs_key_field=['tag_id', 'entity_type', 'entity_id'])


    def vectra_entity_tag_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        List tags for an entity.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_entity_tag_list_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id", required=True)
        entity_type = args.get('entity_type', '').lower()

        # Call Vectra API to get existing entity tags
        existing_tag_res = client.list_entity_tags_request(entity_id=entity_id, entity_type=entity_type)  # type: ignore
        existing_tag_res_status = existing_tag_res.get('status', '')
        if not existing_tag_res_status or not isinstance(existing_tag_res_status,
                                                         str) or existing_tag_res_status.lower() != 'success':
            message = 'Something went wrong.'
            if existing_tag_res.get('message'):
                message += f" Message: {existing_tag_res.get('message')}."
            raise DemistoException(message)
        tags_resp = existing_tag_res.get('tags', [])

        human_readable = '##### No tags were found for the given entity ID and entity type.'
        if tags_resp and isinstance(tags_resp, list):
            tags_resp = [tag.strip() for tag in tags_resp if isinstance(tag, str) and tag.strip()]
            if tags_resp:
                tags_resp = f'**{"**, **".join(tags_resp)}**'
                human_readable = f'##### List of tags: {tags_resp}'

        existing_tag_res['entity_type'] = entity_type
        existing_tag_res['entity_id'] = entity_id
        del existing_tag_res['status']

        return CommandResults(outputs_prefix='Vectra.Entity.Tags',
                              outputs=createContext(remove_empty_elements(existing_tag_res)),
                              readable_output=human_readable, raw_response=existing_tag_res,
                              outputs_key_field=['tag_id', 'entity_type', 'entity_id'])


    def vectra_detections_mark_fixed_command(client: VectraClient, args: Dict[str, Any]):
        """
        Mark the provided detection IDs as fixed.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Raises:
            ValueError: If detection_ids argument is missing or empty.

        Returns:
            CommandResults: The command results.
        """
        # Get function arguments
        detection_ids = args.get('detection_ids')
        # Convert string into list
        detection_ids_list = argToList(detection_ids)
        # Validate detection_ids
        validate_detections_mark_and_unmark_args(detection_ids_list)

        # Call Vectra API to mark detection as fixed
        res = client.mark_or_unmark_detection_fixed_request(detection_ids_list, mark='True')

        if res.get('_meta', {}).get('level') == 'Success' and res.get('_meta').get(  # type: ignore
                'message') == 'Successfully marked detections':
            human_readable = "##### The provided detection IDs have been successfully marked as fixed."
        else:
            raise DemistoException("Something went wrong.")

        return CommandResults(outputs={}, readable_output=human_readable)


    def vectra_detections_unmark_fixed_command(client: VectraClient, args: Dict[str, Any]):
        """
        Unmark the provided detection IDs as fixed.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Raises:
            ValueError: If detection_ids argument is missing or empty.

        Returns:
            CommandResults: The command results.
        """
        # Get function arguments
        detection_ids = args.get('detection_ids')
        # Convert string into list
        detection_ids_list = argToList(detection_ids)
        # Validate detection_ids
        validate_detections_mark_and_unmark_args(detection_ids_list)

        # Call Vectra API to unmark detection as fixed
        res = client.mark_or_unmark_detection_fixed_request(detection_ids_list, mark='False')

        if res.get('_meta', {}).get('level') == 'Success' and res.get('_meta').get(  # type: ignore
                'message') == 'Successfully marked detections':
            human_readable = "##### The provided detection IDs have been successfully unmarked as fixed."
        else:
            raise DemistoException("Something went wrong.")

        return CommandResults(outputs={}, readable_output=human_readable)


    def vectra_assignment_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        List assignments.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Returns:
            CommandResults: The command results.
        """
        validate_assignment_list_command_args(args)
        # Get function arguments
        entity_ids = args.get('entity_ids')
        entity_type = args.get('entity_type', '').lower()
        resolved = args.get('resolved')
        page = arg_to_number(args.get('page', '1'), arg_name='page')
        page_size = arg_to_number(args.get('page_size', '50'), arg_name='page_size')
        assignees = args.get('assignees')
        resolution = args.get('resolution')
        # Convert argument to value
        if resolved:
            resolved = argToBoolean(resolved)
        created_after = arg_to_datetime(args.get('created_after'), arg_name='created_after')
        if created_after:
            created_after = created_after.strftime(DATE_FORMAT)  # type: ignore
        accounts = None
        hosts = None
        if entity_type == 'account':
            accounts = entity_ids
        elif entity_type == 'host':
            hosts = entity_ids
        # Call Vectra API for assignment list
        response = client.list_assignments_request(account_ids=accounts, host_ids=hosts, resolved=resolved,
                                                   assignees=assignees, resolution=resolution,
                                                   created_after=created_after, page=page,  # type: ignore
                                                   page_size=page_size)  # type: ignore
        response = remove_empty_elements(response)
        count = response.get('count', 0)
        assignments = response.get('results', [])
        if assignments:
            human_readable, assignments = get_assignment_list_command_hr(assignments, page=page, page_size=page_size,
                                                                         count=count)
            context = [createContext(assignment) for assignment in assignments]

            return CommandResults(outputs=context, readable_output=human_readable, raw_response=assignments,
                                  outputs_prefix="Vectra.Entity.Assignments", outputs_key_field=['assignment_id'])
        else:
            return CommandResults(outputs={},
                                  readable_output="##### Couldn't find any matching assignments for provided filters.",
                                  raw_response=response)


    def vectra_entity_assignment_add_command(client: VectraClient, args: Dict[str, Any]):
        """
        Create an assignment for specified entity id.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Raises:
            ValueError: If detection_ids argument is missing or empty.

        Returns:
            CommandResults: The command results.
        """
        # Validate command arguments
        validate_entity_assignment_add_command_args(args)
        # Get function arguments
        entity_id = arg_to_number(args.get('entity_id'), arg_name="entity_id")
        entity_type = args.get('entity_type', '').lower()
        user_id = arg_to_number(args.get('user_id'), arg_name="user_id")

        assign_account_id = None
        assign_host_id = None
        if entity_type == 'account':
            assign_account_id = entity_id
        elif entity_type == 'host':
            assign_host_id = entity_id
        # Call Vectra API to create an assignment
        response = client.add_entity_assignment_request(assign_account_id=assign_account_id, assign_host_id=assign_host_id,
                                                        assign_to_user_id=user_id)
        assignment = response.get('assignment', {})
        # Update assignment response
        if assignment:
            assignment['assignment_id'] = assignment['id']
        human_readable = "##### The assignment has been successfully created.\n"
        human_readable += entity_assignment_add_command_hr(assignment)

        return CommandResults(outputs_prefix='Vectra.Entity.Assignments',
                              outputs=createContext(remove_empty_elements(assignment)),
                              readable_output=human_readable, raw_response=assignment, outputs_key_field=['assignment_id'])


    def vectra_entity_assignment_update_command(client: VectraClient, args: Dict[str, Any]):
        """
        Updates an assignment for specified entity id.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Raises:
            ValueError: If detection_ids argument is missing or empty.

        Returns:
            CommandResults: The command results.
        """
        # Validate command arguments
        validate_entity_assignment_update_command_args(args)
        # Get function arguments
        assignment_id = arg_to_number(args.get('assignment_id'), arg_name="assignment_id")
        user_id = arg_to_number(args.get('user_id'), arg_name="user_id")

        # Call Vectra API to update an assignment
        response = client.update_entity_assignment_request(assignment_id=assignment_id, assign_to_user_id=user_id)
        updated_assignment = response.get('assignment', {})
        # Update assignment response
        if updated_assignment:
            updated_assignment['assignment_id'] = updated_assignment['id']
        human_readable = "##### The assignment has been successfully updated.\n"
        human_readable += entity_assignment_add_command_hr(updated_assignment)

        return CommandResults(outputs_prefix='Vectra.Entity.Assignments',
                              outputs=createContext(remove_empty_elements(updated_assignment)),
                              readable_output=human_readable,
                              raw_response=updated_assignment, outputs_key_field=['assignment_id'])


    def vectra_entity_assignment_resolve_command(client: VectraClient, args: Dict[str, Any]):
        """
        Resolve an assignment for specified assignment id.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Raises:
            ValueError: If detection_ids argument is missing or empty.

        Returns:
            CommandResults: The command results.
        """
        # Validate command arguments
        validate_entity_assignment_resolve_command_args(args)
        # Get function arguments
        assignment_id = arg_to_number(args.get('assignment_id'), arg_name="assignment_id")
        outcome = args.get('outcome')
        note = args.get('note')
        triage_as = args.get('triage_as')
        detection_ids = argToList(args.get('detection_ids'))

        # list outcome assignment
        res = client.list_assignment_outcomes_request()
        outcome_list = res.get('results')
        title_to_id = {item["title"]: item["id"] for item in outcome_list}  # type: ignore

        if outcome in title_to_id:
            outcome_id = title_to_id[outcome]
        else:
            outcome_list = ", ".join([item["title"] for item in outcome_list])  # type: ignore
            raise ValueError(ERRORS['INVALID_OUTCOME'].format(outcome_list))

        # Call Vectra API to resolve an assignment
        response = client.resolve_entity_assignment_request(assignment_id=assignment_id, outcome=outcome_id,
                                                            note=note, triage_as=triage_as,  # type: ignore
                                                            detection_ids=detection_ids)
        assignment = response.get('assignment', {})
        # resolve assignment response
        if assignment:
            assignment['assignment_id'] = assignment['id']
        human_readable = "##### The assignment has been successfully resolved."

        return CommandResults(outputs_prefix='Vectra.Entity.Assignments',
                              outputs=createContext(remove_empty_elements(assignment)),
                              readable_output=human_readable, raw_response=assignment, outputs_key_field=['assignment_id'])


    def vectra_assignment_outcome_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        List assignment outcomes.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Returns:
            CommandResults: The command results.
        """
        page = args.get('page', '1')
        page_size = args.get('page_size', '50')
        # Validate page and page_size
        validate_positive_integer_arg(value=page, arg_name='page')
        validate_positive_integer_arg(value=page_size, arg_name='page_size')
        # Get command args
        page = arg_to_number(page, arg_name="page")
        page_size = arg_to_number(page_size, arg_name="page_size")
        # Call Vectra API for assignment outcome list
        response = client.list_assignment_outcomes_request(page=page, page_size=page_size)
        response = remove_empty_elements(response)
        count = response.get('count', 0)
        outcomes = response.get('results', [])
        human_readable, outcomes = get_assignment_outcome_list_command_hr(outcomes=outcomes, page=page,
                                                                          page_size=page_size,
                                                                          count=count)
        context = [createContext(outcome) for outcome in outcomes]

        return CommandResults(outputs=context, readable_output=human_readable, raw_response=outcomes,
                              outputs_prefix="Vectra.Entity.Assignments.Outcomes", outputs_key_field=['id'])


    def vectra_detection_pcap_download_command(client: VectraClient, args: Dict[str, Any]):
        """
        Download the packet capture (PCAP) file associated with a Vectra detection.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): A dictionary containing the arguments for downloading the PCAP file.
                - detection_id (str): The ID of the detection associated with the PCAP file.

        Returns:
            fileResult: A fileResult object containing the downloaded PCAP file content.
        """
        detection_id = args.get('detection_id')
        # Validate detection id
        validate_positive_integer_arg(detection_id, arg_name="detection_id", required=True)

        # Call Vectra API to download detection pcap
        response = client.download_detection_pcap_request(detection_id=detection_id)
        content_disposition = response.headers.get('Content-Disposition', '')
        file_name = content_disposition.split(';')[1].replace('filename=', '').replace('"', '')

        return fileResult(filename=file_name, data=response.content)


    def vectra_entity_detections_mark_fixed_command(client: VectraClient, args: Dict[str, Any]):
        """
        Mark the provided entity detections as fixed.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Raises:
            ValueError: If detection_ids argument is missing or empty.

        Returns:
            CommandResults: The command results.
        """
        validate_entity_detections_mark_fix_command_args(args)
        # Get function arguments
        entity_id = args.get('entity_id')
        entity_type = args.get('entity_type', '').lower()
        response = client.get_entity_request(entity_id=entity_id, entity_type=entity_type)
        detection_set = response.get('detection_set')
        detection_ids = [url.split("/")[-1] for url in detection_set] if detection_set else ''

        if not detection_ids:
            return CommandResults(
                readable_output=f"There are no detections to mark as fixed for this entity ID:{entity_id}.")

        # Call Vectra API to mark detection as fixed
        res = client.mark_or_unmark_detection_fixed_request(detection_ids=detection_ids, mark='True')  # type: ignore
        if res.get('_meta', {}).get('level') == 'Success' and res.get('_meta').get(  # type: ignore
                'message') == 'Successfully marked detections':
            human_readable = f"##### The detections ({', '.join(detection_ids)}) of the provided entity ID have been " \
                             f"successfully marked as fixed."
        else:
            raise DemistoException("Something went wrong.")

        return CommandResults(readable_output=human_readable)


    def vectra_group_list_command(client: VectraClient, args: Dict[str, Any]):
        """
        Retrieves a list of groups.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments provided by the user.

        Returns:
            CommandResults: The command results containing the outputs, readable output, raw response, and outputs key field.
        """
        validate_group_list_command_args(args)

        # Get function arguments
        group_type = args.get('group_type') or ''
        if group_type:
            group_type = group_type.lower()
        importance = args.get('importance') or ''
        if importance:
            importance = importance.lower()
        account_names = argToList(args.get('account_names') or '')
        domains = argToList(args.get('domains') or '')
        host_ids = argToList(args.get('host_ids') or '')
        host_names = argToList(args.get('host_names') or '')
        ips = argToList(args.get('ips') or '')
        description = args.get('description') or ''
        last_modified_timestamp = arg_to_datetime(args.get('last_modified_timestamp'), arg_name='last_modified_timestamp')
        last_modified_by = args.get('last_modified_by') or ''
        group_name = args.get('group_name') or ''

        # Call Vectra API to get groups
        response = client.list_group_request(group_type=group_type, account_names=account_names, domains=domains,
                                             host_ids=host_ids, host_names=host_names, importance=importance, ips=ips,
                                             description=description, last_modified_timestamp=last_modified_timestamp,
                                             last_modified_by=last_modified_by, group_name=group_name)  # type: ignore
        count = response.get('count')
        if count == 0:
            return CommandResults(outputs={},
                                  readable_output="##### Couldn't find any matching groups for provided filters.",
                                  raw_response=response)
        groups = response.get('results')

        # Prepare context data
        human_readable = get_group_list_command_hr(groups)  # type: ignore
        context = [createContext(group) for group in remove_empty_elements(groups)]  # type: ignore

        return CommandResults(outputs_prefix='Vectra.Group', outputs=context, readable_output=human_readable,
                              raw_response=groups, outputs_key_field=['group_id'])


    def vectra_group_unassign_command(client: VectraClient, args: Dict[str, Any]):
        """
        Unassign members in Group.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Returns:
            CommandResults: The command results.
        """
        validate_group_assign_and_unassign_command_args(args)
        group_id = args.get('group_id')
        members = args.get('members')

        # Call to get group details
        group = client.get_group_request(group_id=group_id)
        group_type = group.get('type')
        updated_members = group_members = group.get('members')
        members_list = argToList(members)
        removed_members = []

        if group_type.lower() == "ip" or group_type.lower() == "domain":  # type: ignore
            for member in members_list:
                if member in group_members:  # type: ignore
                    removed_members.append(member)
                    updated_members.remove(member)  # type: ignore
        elif group_type.lower() == "account":  # type: ignore
            uids = [i.get('uid') for i in group_members]  # type: ignore
            for member in members_list:
                if member in uids:
                    removed_members.append(member)
                    uids.remove(member)
            updated_members = uids
        elif group_type.lower() == "host":  # type: ignore
            ids = [str(i.get('id')) for i in group_members]  # type: ignore
            for member in members_list:
                if member in ids:
                    removed_members.append(member)
                    ids.remove(member)
            updated_members = ids
        if not removed_members:
            members_list = [re.escape(member) for member in members_list]
            return CommandResults(readable_output=f"##### Member(s) {', '.join(members_list)} do not exist in the group.")
        # Call Vectra API to unassign members in group
        res = client.update_group_members_request(group_id=group_id, members=updated_members)
        updated_group = remove_empty_elements(res)

        human_readable = get_group_unassign_and_assign_command_hr(group=updated_group, changed_members=removed_members,
                                                                  assign_flag=False)

        return CommandResults(outputs_prefix='Vectra.Group', outputs=createContext(updated_group),
                              readable_output=human_readable,
                              raw_response=updated_group, outputs_key_field=['group_id'])


    def vectra_group_assign_command(client: VectraClient, args: Dict[str, Any]):
        """
        Assign members in Group.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict[str, Any]): The command arguments.

        Returns:
            CommandResults: The command results.
        """
        validate_group_assign_and_unassign_command_args(args)
        group_id = args.get('group_id')
        members = args.get('members')

        # Call to get group details
        group = client.get_group_request(group_id=group_id)
        group_type = group.get('type')
        updated_members = group_members = group.get('members')
        members_list = argToList(members)
        added_members = []

        if group_type.lower() == "ip" or group_type.lower() == "domain":  # type: ignore
            for member in members_list:
                if member not in group_members:  # type: ignore
                    added_members.append(member)
                    updated_members.append(member)  # type: ignore
        elif group_type.lower() == "account":  # type: ignore
            uids = [i.get('uid') for i in group_members]  # type: ignore
            for member in members_list:
                if member not in uids:
                    added_members.append(member)
                    uids.append(member)
            updated_members = uids
        elif group_type.lower() == "host":  # type: ignore
            ids = [str(i.get('id')) for i in group_members]  # type: ignore
            for member in members_list:
                if member not in ids:
                    added_members.append(member)
                    ids.append(member)
            updated_members = ids
        if not added_members:
            members_list = [re.escape(member) for member in members_list]
            return CommandResults(readable_output=f"##### Member(s) {', '.join(members_list)} are already in the group.")
        # Call Vectra API to assign members in group
        res = client.update_group_members_request(group_id=group_id, members=updated_members)
        updated_group = remove_empty_elements(res)

        human_readable = get_group_unassign_and_assign_command_hr(group=updated_group, changed_members=added_members,
                                                                  assign_flag=True)

        return CommandResults(outputs_prefix='Vectra.Group', outputs=createContext(updated_group),
                              readable_output=human_readable,
                              raw_response=updated_group, outputs_key_field=['group_id'])


    def test_module(client: VectraClient) -> str:
        """
        Tests the connection to the Vectra server.

        Args:
            client (VectraClient): An instance of the VectraClient class.

        Returns:
            str: A message indicating the success of the test.
        """
        params = demisto.params()
        if params.get('isFetch'):
            validate_configuration_parameters(params)
        client.list_entities_request(page_size=1)
        return "ok"


    def get_modified_remote_data_command(client: VectraClient, args: Dict) -> GetModifiedRemoteDataResponse:
        """
        Get modified remote data from the Vectra platform and prepare it for mirroring in XSOAR.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict): A dictionary containing the arguments for retrieving modified remote data.

        Returns:
            GetModifiedRemoteDataResponse: List of incidents IDs which are modified since the last update.
        """
        command_args = GetModifiedRemoteDataArgs(args)
        command_last_run_date = dateparser.parse(
            command_args.last_update, settings={'TIMEZONE': 'UTC'}).strftime(DATE_FORMAT)  # type: ignore
        modified_entities_ids = []

        demisto.debug(f'Last update date of get-modified-remote-data command is {command_last_run_date}.')
        next_url = None
        page = 1
        page_size = 500
        while True:
            if next_url:
                # Parse the URL
                parsed_url = urlparse(next_url)
                # Extract the query parameters
                query_params = parse_qs(parsed_url.query)
                page = arg_to_number(query_params.get('page', [''])[0], arg_name='page')  # type: ignore
                page_size = arg_to_number(query_params.get('page_size', [''])[0], arg_name='page_size')
                command_last_run_date = query_params.get('last_modified_timestamp_gte', [''])[0]

            response = client.list_entities_request(last_modified_timestamp=command_last_run_date,  # type: ignore
                                                    page=page, page_size=page_size)

            entities = response.get('results', [])
            next_url = response.get('next_url')
            if len(entities) == 0:
                break
            # Extra ID and type of the entities
            modified_entities_ids.extend([str(entity.get('id')) + '-' + entity.get('type') for entity in entities])
            # If there is no data on the next page
            if not next_url:
                break
            # Mirroring limit
            if len(modified_entities_ids) > MAX_MIRRORING_LIMIT:
                demisto.debug("Max mirroring limit reached.")
                break
        # Filter out None values if there are any.
        modified_entities_ids: List[str] = list(filter(None, modified_entities_ids))  # type: ignore
        demisto.debug(f'Performing get-modified-remote-data command. Numbers Entity IDs to update in XSOAR:'
                      f' {len(modified_entities_ids)}')
        demisto.debug(f'Performing get-modified-remote-data command. Entity IDs to update in XSOAR:'
                      f' {modified_entities_ids}')

        # Filter out any duplicate incident IDs.
        updated_incident_ids = list(set(modified_entities_ids))

        # At max 5,000 incidents should be updated.
        updated_incident_ids = updated_incident_ids[:5000]

        return GetModifiedRemoteDataResponse(modified_incident_ids=updated_incident_ids)


    def get_remote_data_command(client: VectraClient, args: Dict) -> GetRemoteDataResponse:
        """
        Get remote data for a specific entity from the Vectra platform and prepare it for mirroring in XSOAR.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict): A dictionary containing the arguments for retrieving remote data.
                - id (str): The ID of the entity to retrieve.
                - lastUpdate (str): The timestamp of the last update received for this entity.

        Returns:
            GetRemoteDataResponse: An object containing the remote incident data and any new entries to return to XSOAR.
        """
        new_entries_to_return = []

        dbot_mirror_id: str = args.get('id')  # type: ignore
        demisto.debug(f'dbot_mirror_id:{dbot_mirror_id}')
        entity_id_type = dbot_mirror_id.split('-')
        vectra_entity_id = entity_id_type[0] if entity_id_type else ""
        vectra_entity_type = entity_id_type[1] if entity_id_type else ""
        demisto.debug(f'vectra_entity_id:{vectra_entity_type}')
        demisto.debug(f'Getting update for remote {vectra_entity_id}.')

        command_last_run_dt = arg_to_datetime(args.get('lastUpdate'), arg_name="lastUpdate", required=True)
        command_last_run_timestamp = command_last_run_dt.strftime(DATE_FORMAT)  # type: ignore
        demisto.debug(f'The time when the last time get-remote-data command is called for current incident is '
                      f'{command_last_run_timestamp}.')

        # Retrieve the latest entity data from the Vectra platform.
        remote_incident_data = client.get_entity_request(entity_id=int(vectra_entity_id), entity_type=vectra_entity_type)
        if not remote_incident_data:
            return 'Incident was not found.'  # type: ignore
        # Get detection set.
        detection_set = remote_incident_data.get('detection_set', [])

        params = demisto.params()
        # Collect the detections if the detection set is not empty.
        if len(detection_set) != 0:
            detections_ids = ','.join([url.split("/")[-1] for url in detection_set])
            detections_data = client.list_detections_request(detection_type=params.get('detection_type'),
                                                             detection_category=params.get('detection_category'),
                                                             ids=detections_ids)
            detections = detections_data.get('results', [])
        else:
            detections = []
        response = {}
        # Add detection details to the entity.
        remote_incident_data.update({'detection_details': detections})

        if vectra_entity_type == "account":
            response = client.list_assignments_request(account_ids=vectra_entity_id)
        elif vectra_entity_type == "host":
            response = client.list_assignments_request(host_ids=vectra_entity_id)

        assignment_details = response.get('results', [])
        assignment_details = assignment_details[0] if len(assignment_details) > 0 else {}
        if assignment_details and not assignment_details.get("resolved_by"):
            assignment_details["resolved_by"] = {"username": ""}
            assignment_details["outcome"] = {"title": ""}
            assignment_details["date_resolved"] = ""
        remote_incident_data.update({'assignment_details': assignment_details})

        last_modified_timestamp = arg_to_datetime(remote_incident_data.get('last_modified_timestamp'))

        if command_last_run_dt > last_modified_timestamp:  # type: ignore
            demisto.debug(f'Nothing new in the Vectra entity {entity_id_type}.')
        else:
            demisto.debug(f'The Vectra entity {entity_id_type} is updated.')

        notes = remote_incident_data.get('notes')

        if notes:
            for note in notes:
                if "[Mirrored From XSOAR]" in note.get('note'):
                    demisto.debug(f"Skipping the note {note.get('id')} as it is mirrored from XSOAR.")
                    continue
                note_date_modified = arg_to_datetime(note.get('date_modified'))
                if note_date_modified:
                    if note_date_modified <= command_last_run_dt:  # type: ignore
                        demisto.debug(
                            f"Skipping the note {note.get('id')} as it was modified earlier than the command last run "
                            "timestamp.")
                        continue
                else:
                    note_date_created = arg_to_datetime(note.get('date_created'), arg_name='date_created', required=True)
                    if note_date_created <= command_last_run_dt:  # type: ignore
                        demisto.debug(
                            f"Skipping the note {note.get('id')} as it is older than the command last run timestamp.")
                        continue
                new_entries_to_return.append({
                    'Type': EntryType.NOTE,
                    'Contents': f'[Mirrored From Vectra]\n'
                                f'Added By: {note.get("created_by")}\n'
                                f'Added At: {note.get("date_created")} UTC\n'
                                f'Note: {note.get("note")}',
                    'ContentsFormat': EntryFormat.TEXT,
                    'Note': True,
                })
        demisto.debug(f'remote_incident_data:{remote_incident_data}')
        return GetRemoteDataResponse(remote_incident_data, new_entries_to_return)


    def update_remote_system_command(client: VectraClient, args: Dict) -> str:
        """
        Update a remote system based on changes in the XSOAR incident.

        Args:
            client (VectraClient): An instance of the VectraClient class.
            args (Dict): A dictionary containing the arguments required for updating the remote system.

        Returns:
            str: The ID of the updated remote entity.
        """
        parsed_args = UpdateRemoteSystemArgs(args)
        # Get remote incident ID
        remote_entity_id = parsed_args.remote_incident_id
        mirror_entity_id = parsed_args.data.get('vectraxdrentityid', '')
        demisto.debug(f'Remote Incident ID: {remote_entity_id}')
        delta = parsed_args.delta
        # Get XSOAR incident id
        xsoar_incident_id = parsed_args.data.get('id', '')
        demisto.debug(f'XSOAR Incident ID: {xsoar_incident_id}')
        new_entries = parsed_args.entries
        xsoar_tags: List = parsed_args.delta.get('tags', [])
        remote_entity_type = parsed_args.data.get('vectraxdrentitytype', '').lower()

        # For notes
        if new_entries:
            for entry in new_entries:
                entry_id = entry.get("id")
                demisto.debug(f'Sending the entry with ID: {entry_id} and Type: {entry.get("type")}')
                # Get note content and user
                entry_content = re.sub(r'([^\n])\n', r'\1\n\n', entry.get('contents', ''))
                if len(entry_content) > MAX_OUTGOING_NOTE_LIMIT:
                    demisto.info(
                        f"Skipping outgoing mirroring for entity note with XSOAR Incident ID:{xsoar_incident_id}, "
                        "because the note length exceeds 8000 characters.")
                else:
                    entry_user = entry.get('user', 'dbot') or 'dbot'

                note_str = f'[Mirrored From XSOAR] XSOAR Incident ID: {xsoar_incident_id} \n\n' \
                           f'Note: {entry_content} \n\n' \
                           f'Added By: {entry_user}'
                # API request for adding notes
                client.add_entity_note_request(entity_id=mirror_entity_id, entity_type=remote_entity_type, note=note_str)

        # For tags
        res = client.list_entity_tags_request(entity_id=mirror_entity_id, entity_type=remote_entity_type)
        vectra_tags = res.get('tags')
        if xsoar_tags:
            demisto.debug(f'Sending the tags: {xsoar_tags}')
            client.update_entity_tags_request(entity_id=mirror_entity_id, entity_type=remote_entity_type,
                                              tags=xsoar_tags)
        # Check if all tags from XSOAR removed
        elif not xsoar_tags and vectra_tags and 'tags' in delta.keys():
            demisto.debug(f'Sending the tags: {xsoar_tags}')
            client.update_entity_tags_request(entity_id=mirror_entity_id, entity_type=remote_entity_type,
                                              tags=xsoar_tags)
        # For Closing notes
        delta_keys = parsed_args.delta.keys()
        if 'closingUserId' in delta_keys:
            # Check if incident status is Done
            if parsed_args.incident_changed and parsed_args.inc_status == IncidentStatus.DONE:
                close_notes = parsed_args.data.get('closeNotes', '')
                close_reason = parsed_args.data.get('closeReason', '')
                close_user_id = parsed_args.data.get('closingUserId', '')

                if len(close_notes) > MAX_OUTGOING_NOTE_LIMIT:
                    demisto.info(
                        f"Skipping outgoing mirroring for closing notes with XSOAR Incident ID {xsoar_incident_id}, "
                        "because the note length exceeds 8000 characters.")
                else:
                    closing_note = f'[Mirrored From XSOAR] XSOAR Incident ID: {xsoar_incident_id}\n\n' \
                                   f'Close Reason: {close_reason}\n\n' \
                                   f'Closed By: {close_user_id}\n\n' \
                                   f'Close Notes: {close_notes}'
                    demisto.debug(f'Closing Comment: {closing_note}')
                    client.add_entity_note_request(entity_id=remote_entity_id, entity_type=remote_entity_type,
                                                   note=closing_note)

        return remote_entity_id


    def main():
        params = demisto.params()
        remove_nulls_from_dictionary(params)
        # get connectivity parameters
        server_url = params.get('server_url', '').strip()
        client_id = params.get('client_id', '').strip()
        client_secret_key = params.get('client_secret_key', '').strip()
        verify_certificate = not argToBoolean(params.get('insecure', False))
        proxy = argToBoolean(params.get('proxy', False))

        command = demisto.command()
        demisto.debug(f"Command being called is {command}")

        commands: Dict[str, Callable] = {
            'vectra-user-list': vectra_user_list_command,
            'vectra-entity-list': vectra_entity_list_command,
            'vectra-entity-describe': vectra_entity_describe_command,
            'vectra-entity-detection-list': vectra_entity_detection_list_command,
            'vectra-detection-describe': vectra_detection_describe_command,
            'vectra-entity-note-list': vectra_entity_note_list_command,
            'vectra-entity-note-add': vectra_entity_note_add_command,
            'vectra-entity-note-update': vectra_entity_note_update_command,
            'vectra-entity-note-remove': vectra_entity_note_remove_command,
            'vectra-entity-tag-add': vectra_entity_tag_add_command,
            'vectra-entity-tag-remove': vectra_entity_tag_remove_command,
            'vectra-entity-tag-list': vectra_entity_tag_list_command,
            'vectra-detections-mark-fixed': vectra_detections_mark_fixed_command,
            'vectra-detections-unmark-fixed': vectra_detections_unmark_fixed_command,
            'vectra-assignment-list': vectra_assignment_list_command,
            'vectra-entity-assignment-add': vectra_entity_assignment_add_command,
            'vectra-entity-assignment-update': vectra_entity_assignment_update_command,
            'vectra-entity-assignment-resolve': vectra_entity_assignment_resolve_command,
            'vectra-assignment-outcome-list': vectra_assignment_outcome_list_command,
            'vectra-detection-pcap-download': vectra_detection_pcap_download_command,
            'vectra-entity-detections-mark-fixed': vectra_entity_detections_mark_fixed_command,
            'vectra-group-list': vectra_group_list_command,
            'vectra-group-assign': vectra_group_assign_command,
            'vectra-group-unassign': vectra_group_unassign_command
        }
        try:
            result = None
            # Creates vectra client
            client = VectraClient(
                server_url=server_url, client_id=client_id, client_secret_key=client_secret_key, verify=verify_certificate,
                proxy=proxy
            )
            # Get Command args
            args = demisto.args()
            if command == "test-module":
                result = test_module(client)
            elif command == "fetch-incidents":
                # Fetch incidents
                incidents = fetch_incidents(client, params)
                # Ingest incidents in XSOAR
                demisto.debug(f'{len(incidents)} incidents are created successfully in XSOAR.')
                demisto.incidents(incidents)
            elif command == 'get-modified-remote-data':
                result = get_modified_remote_data_command(client, args)  # type: ignore
            elif command == 'get-remote-data':
                result = get_remote_data_command(client, args)  # type: ignore
            elif command == 'update-remote-system':
                result = update_remote_system_command(client, args)
            elif command in commands:
                # remove nulls from dictionary and trim space from args
                remove_nulls_from_dictionary(trim_spaces_from_args(args))
                result = commands[command](client, args)
            else:
                raise NotImplementedError(f"Command {command} is not implemented")

            return_results(result)  # Returns either str, CommandResults and a list of CommandResults

        # Log exceptions and return errors
        except Exception as e:
            return_error(f"Failed to execute {command} command.\nError:\n{str(e)}")


    if __name__ in ("__main__", "__builtin__", "builtins"):  # pragma: no cover
        main()

    register_module_line('VectraXDR', 'end', __line__())
  subtype: python3
  type: python
tests:
- No tests (auto formatted)
marketplaces:
- xsoar
- marketplacev2
fromversion: 6.8.0
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAAHgoC9OAAAJ2ElEQVR4nGL8//8/A1mAgYEBAAAA//9iIlsnAwMDAAAA///Cqdm7R9cAn0bvHl0BAAAAAP//YgA526tbJwFEQ9n/vbp1GmB8NPH/cLH//xkAAAAA//8C27y15PICNIPrvXt0/3v36CYgC24tuczo3aOrALa5R9cBAAAA//8iP8AYGBgAAAAA//8iP8AYGBgAAAAA//8i32YGBgYAAAAA//8i32YGBgYAAAAA///CF1UH8OpkYGAAAAAA//9iQdMA88PBrSWXHWBi0FCGyQkyMDAEbC25vAAAAAD//4LFoQN6XKLTyOrA+P9/BgAAAAD//yI/wBgYGAAAAAD//yI/wBgYGAAAAAD//6LIZrIBAwMDAAAA//+iyNVkAwYGBgAAAAD//4JbjBSLcDYo3yAbjqamAJ9eKFsAWRwux8DAAAAAAP//gicv5CQEYhPyzdaSyxOI8PF7BgYGsLkwM8HsksuMAAAAAP//Gpg4ZmBgAAAAAP//Gpg4ZmBgAAAAAP//GhgfMzAwAAAAAP//GhgfMzAwAAAAAP//GhiLGRgYAAAAAP//GhiLGRgYAAAAAP//ItliUBWAXmcSqQ9RJjAwMAAAAAD//8Ko0aF8AfTaGyp+AV0MH0aqLUDmIez4/58BAAAA//8CFyCguga5HoLSKKUQAwND49aSy3jbJlCfIetJhNLvkc1mYGBgAAAAAP//QvYNSr2Fw8cGJPgWVl8KYNjx/z8DAAAA//9CycfoRRuyT5DaPvdhfGJ9j6wWbEfJZUYAAAAA//8amAKEgYEBAAAA//8amOzEwMAAAAAA//8aGIsZGBgAAAAA//8aGIsZGBgAAAAA//8asDgeEMDAwAAAAAD//xqwkB4QwMDAAAAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//wtZlc9xachmjrwft/xlsLbksgF55oAMslcxFBgaGDwwMDPZQviIDAwOoUw7jYwPgbiMBuyZuLbkM71RA7XzAwMAgD/MHtMHyAOwnBgYGAAAAAP//wlaFgrqa6NXyAa9unQf41KBX2diqcmIaKiSIYzSQvLp1Pnh16yxAciNKg+f///8MAAAAAP//wkjS0NjZD2vKQUNMYWvJZfDQB5GAYOOIEgCNddDAAHLTApSCNmwtuQx2N1RuPkqTlIGBAQAAAP//wlktISdH9NYdVK6QgYHhAja9SElpPgMDw0KYI6B92n5Q6w99nAmlBUikOMgNoO4qlA1qhTbgUAexj4GBAQAAAP//Gln1MAMDAwAAAP//GlmlNAMDAwAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//Gll5mIGBAQAAAP//GlkxzMDAAAAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//GlkeZmBgAAAAAP//QukP0wJ49+iCGvSgAXFQR6Nha8llUK+GlvaBOjoftpZcBvXywB0W+HwYAwMDAAAA//+CexjWk8E18gvtdQiCHIyvU47U+QdZkg8VPsjAwADqMeV79+iCe1/EDCJABx1wDhLgcOt5KA2TA/kL4mEGBgYAAAAA//8i2PlHGgD4QKizjjzmDjULPg6PbzwftH4BZAcOezHWNiB19lHkoGIgPdgHKP7/ZwAAAAD//0LPw6BZiv1YQs0eNLSDL0bQAMgMUB8UI/luLbmMtQ9NJoCbD50b5oeuJsDuDwYGBgAAAAD//0LJw9DpHtAogQNsDAiarB6ia8SVJGHJDMtCEnIBaAFKPQ67kOeqQXl2IZo/ElDcwcDAAAAAAP//wlZowUIHlgdAsYuRV4iZ5aESQBnJgM4I7kcb3oHFLvJwjiPUHwgPMzAwAAAAAP//wjamBVYACh3oeBZG7BIBDkLHmKgOkFIesufgsYvkD0x1DAwMAAAAAP//wlUtwUIHZ0xizL0iWQQbXkUe9oXOAYIcIU+F1AGPPai56LGLoQ7MY2BgAAAAAP//wtrwQBqXBlUnuADIIGwYZgbIU6BQB42AgjxO9IQnIYAUe6AqB2RuIz5/wBfEMDAwAAAAAP//GlkDAAwMDAAAAAD//xpZTUsGBgYAAAAA//8aWR5mYGAAAAAA//8aWR5mYGAAAAAA//8aWR5mYGAAAAAA//8aWR5mYGAAAAAA//8aWR5mYGAAAAAA//8aWR5mYGAAAAAA//8acfXwiAIMDAwAAAAA//8acSl6RAEGBgYAAAAA//8ajeDhDBgYGAAAAAD//xqN4OEMGBgYAAAAAP//Go3g4QwYGBgAAAAA//8ajeDhDBgYGAAAAAD//xqN4OEMGBgYAAAAAP//Go3g4QwYGBgAAAAA///CmHGAzs+Apiz4kff0Egtgcz5Q5fD5IELzwPgAjlW0DtCZBHk8Wj9C54QnwGYwCc01EwGQ9zmTYxZoygrkHmI2q8KmiECrkVHsRpIHL9gHhQX6InkGBgYGAAAAAP//wrdMGraCnuhIxhW5DKgRjHN5NS6AvBMBbUEBRgQiqQuATvrDIiBwa8nlDdCVELimuEGBGQ/dqYARWFAAWkUBdj9SBINmkoiZFQbZCwoTfShfEbYiAxtAWlYO8yvWTAfKlFhXkDAwMAAAAAD//8I7kkVKJKNFbiF6CkWKYKxbR4gB3j26F6CB8xC6zYSqE7HQZTegKXeiEjVSBGNdg0+JPiS3gAA4IZCc6RgYGAAAAAD//8K7Vgm0mwNqqD3IUbgMRYtcjE0MaAC0bIcYt8HAA6jnCqCR+5HEXSb0AKBwIibA0XMw1nDCFrkgBlp8gMIFfzgwMDAAAAAA//8iuBiNkKHQonA9lEsochmQihxiQSM0UGDFKjVX/lALgIp1ECYGgIp/cHWBTTGuyIUBaHyASwCCkczAwAAAAAD//yJqtSHUUHDxiGwoWgOAmMhloKCIXgD1uD36CsJBAAgW0UjFMqi+JCtyYQC6bIZwJDMwMAAAAAD//yK6mwTdjwZa1iIPMpTMyCUbQD1rCNXfD1oIRczpTKBGGTlnQtDA/aAiHB5+6PLePbqwBAwCeBtfxJgHBgwMDAAAAAD//yJ5uhBL14CoHEnNbhI0wiZAW5XEAFBAgHZj4m2U0aORhaQH1CoG7VoFJVRQ5IKKeLgYkf5CNg+z4cnAwAAAAAD//xry88HQfrsD2pZdkCdBjcLBWF/TDzAwMAAAAAD//xqd8B/OgIGBAQAAAP//Gh2qHM6AgYEBAAAA//8ajeDhDBgYGAAAAAD//xqN4OEMGBgYAAAAAP//Go3g4QwYGBgAAAAA//8ajeDhDBgYGAAAAAD//xqN4OEMGBgYAAAAAP//Go3g4QwYGBgAAAAA//8DAKjiQxWWocItAAAAAElFTkSuQmCC
detaileddescription: "### Partner Contributed Integration\n#### Integration Author: Vectra AI\nSupport and maintenance for this integration are provided by the author. Please use the following contact details:\n- **Email**: [support@vectra.ai](mailto:support@vectra.ai)\n- **URL**: [https://support.vectra.ai](https://support.vectra.ai)\n***\n### Vectra XDR Integration\n\nVectra XDR pack allows the security operations center to create incidents based on prioritized Entities, powered by Vectra AI's Attack Signal Intelligence. This pack enables security teams to synchronize the Vectra XDR Entities with Cortex XSOAR incidents in real time, making it feasible to manage operations from a single place.\n\nThis integration was integrated and tested with version 3.3 of Vectra API.\n\n### Instance Configuration\n\nThe integration only supports one type of ingestion:\n\n1. Vectra XDR Entity: Fetch active Vectra XDR Entity as an XSOAR incident, including related active detections for each fetched Entity.\n\n#### Vectra XDR Entity\n\nTo fetch Vectra XDR Entity follow the next steps:\n\n1. Select Fetches incidents.\n2. Under Classifier, select \"N/A\". \n3. Under Incident type, select \"Vectra XDR Entity\".\n4. Under Mapper (incoming), select \"Vectra XDR - Incoming Mapper\" for default mapping.\n5. Enter connection parameters. (Server URL, Client ID & Client Secret Key)\n6. Select SSL certificate validation and Proxy if required.\n7. Update \"Max Fetch\" & \"First Fetch Time\" based on your requirements.\n8. Select the Incident Mirroring Direction:\n    1. Incoming - Mirrors changes from the Vectra XDR Entity into the Cortex XSOAR incident.\n    2. Outgoing - Mirrors changes from the Cortex XSOAR incident to the Vectra XDR Entity.\n    3. Incoming And Outgoing - Mirrors changes both Incoming and Outgoing directions on incidents.\n9. Enter the relevant tag name for mirror notes.\n**Note:** This value is mapped to the **dbotMirrorTags** incident field in Cortex XSOAR, which defines how Cortex XSOAR handles notes when you tag them in the War Room. This is required for mirroring notes from Cortex XSOAR to Vectra XDR.\n10. Provide appropriate values for filtering Entities, such as Entity Type, Prioritization, and Tags. Additionally, specify filters for detections, including Detection Name, Detection Category, and Detection Type.\n**Note:** Filters for Entities and Detections are combined using 'OR' logic, while filters\n11. Adjust the Urgency Score to categorize Entity severity in Cortex XSOAR. There are three fields for this mapping:\n    1. Input a value for 'Low' severity. Scores up to this limit are labelled as Low.\n    2. The next value is for 'Medium' severity. Scores up to this limit are labelled as Medium.\n    3. The third value is for 'High' severity. Scores up to this limit are labelled as High. Any score above this is marked as 'Critical' severity.\n\n**Notes for mirroring:**\n\n- The mirroring settings apply only for incidents that are fetched after applying the settings.\n- The mirroring is strictly tied to Incident type \"Vectra XDR Entity\" & Incoming mapper \"Vectra XDR - Incoming Mapper\". If you want to change or use your custom incident type/mapper then make sure changes related to these are present.\n- If you want to use the mirror mechanism and you're using custom mappers, then the incoming mapper must contain the following fields: dbotMirrorDirection, dbotMirrorId, dbotMirrorInstance, dbotMirrorTags.\n- To use a custom mapper, you must first duplicate the mapper and update the fields in the copy of the mapper. If you detach the out-of-the-box mapper and make changes to it, the pack does not automatically get updates.\n- If you are using a custom incident type, you also need to create custom corresponding incoming mappers.\n- Following new fields are introduced in the response to the incident to enable the mirroring:\n  - mirror_direction: This field determines the mirroring direction for the incident. It is a required field for XSOAR to enable mirroring support.\n  - mirror_tags: This field determines what would be the tag needed to mirror the XSOAR entry out to Vectra XDR. It is a required field for XSOAR to enable mirroring support.\n  - mirror_instance: This field determines from which instance the XSOAR incident was created. It is a required field for XSOAR to enable mirroring support.\n\nFor more information about this integration, visit [Vectra's knwoledge base](https://support.vectra.ai/s/article/KB-VS-1692).\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/vectra-xdr)"
